#!/usr/bin/env python3
"""
Migration Summary for C2PUML Test Framework

This script creates a readable summary of the migration recommendations
generated by todo_recommendations.py and provides specific action items
for each test file.
"""

import json
from pathlib import Path
from collections import defaultdict

def load_recommendations():
    """Load the recommendations from JSON file"""
    with open("todo_recommendations.json", 'r') as f:
        return json.load(f)

def print_executive_summary(data):
    """Print executive summary"""
    metadata = data["analysis_metadata"]
    
    print("="*80)
    print("C2PUML TEST MIGRATION - EXECUTIVE SUMMARY")
    print("="*80)
    print(f"üìã Total Files Analyzed: {metadata['total_files_analyzed']}")
    print(f"üî¥ High Priority: {metadata['high_priority_count']} files")
    print(f"üü° Medium Priority: {metadata['medium_priority_count']} files") 
    print(f"üü¢ Low Priority: {metadata['low_priority_count']} files")
    print()
    print(f"üìù Data JSON Strategy: {metadata['data_json_strategy_count']} files")
    print(f"üìÑ Explicit Files Strategy: {metadata['explicit_files_strategy_count']} files")
    print(f"‚úÇÔ∏è Files Requiring Split: {metadata['split_required_count']} files")

def print_critical_findings(recommendations):
    """Print critical findings that need immediate attention"""
    print("\n" + "="*80)
    print("‚ö†Ô∏è CRITICAL FINDINGS")
    print("="*80)
    
    # Files that need splitting
    split_files = [r for r in recommendations if r['analysis']['should_split']]
    if split_files:
        print(f"\nüö® {len(split_files)} LARGE FILES REQUIRE SPLITTING:")
        for rec in split_files:
            file_name = Path(rec['original_file']).name
            methods = rec['analysis']['total_methods']
            suggestions = rec['analysis']['split_suggestions']
            print(f"   ‚Ä¢ {file_name}: {methods} methods ‚Üí split into {len(suggestions)} files")
            for suggestion in suggestions[:3]:  # Show first 3 suggestions
                print(f"     - {suggestion}")
            if len(suggestions) > 3:
                print(f"     - ... and {len(suggestions) - 3} more")
    
    # High complexity files
    complex_files = [r for r in recommendations 
                    if r['analysis']['total_methods'] > 20 and r['estimated_effort'] == 'high']
    if complex_files:
        print(f"\nüî• {len(complex_files)} HIGH COMPLEXITY FILES:")
        for rec in sorted(complex_files, key=lambda x: x['analysis']['total_methods'], reverse=True)[:5]:
            file_name = Path(rec['original_file']).name
            methods = rec['analysis']['total_methods']
            strategy = rec['analysis']['recommended_strategy']
            print(f"   ‚Ä¢ {file_name}: {methods} methods, {strategy} strategy")

def print_strategy_breakdown(recommendations):
    """Print detailed strategy breakdown"""
    print("\n" + "="*80)
    print("üìä STRATEGY BREAKDOWN")
    print("="*80)
    
    # Group by strategy
    strategies = defaultdict(list)
    for rec in recommendations:
        strategy = rec['analysis']['recommended_strategy']
        strategies[strategy].append(rec)
    
    for strategy, files in strategies.items():
        print(f"\nüìÅ {strategy.upper().replace('_', ' ')} ({len(files)} files):")
        
        # Sort by priority and method count
        sorted_files = sorted(files, key=lambda x: (
            0 if x['analysis']['priority'] == 'high' else 1 if x['analysis']['priority'] == 'medium' else 2,
            -x['analysis']['total_methods']
        ))
        
        for rec in sorted_files[:10]:  # Show top 10
            file_name = Path(rec['original_file']).name
            methods = rec['analysis']['total_methods']
            priority = rec['analysis']['priority']
            category = rec['analysis']['category']
            print(f"   ‚Ä¢ {file_name} [{category}]: {methods} methods, {priority} priority")

def print_migration_phases(recommendations):
    """Print recommended migration phases"""
    print("\n" + "="*80)
    print("üöÄ RECOMMENDED MIGRATION PHASES")
    print("="*80)
    
    # Phase 1: High priority, low effort
    phase1 = [r for r in recommendations 
             if r['analysis']['priority'] == 'high' and r['estimated_effort'] in ['low', 'medium']]
    
    # Phase 2: High priority, high effort (split or keep)
    phase2 = [r for r in recommendations 
             if r['analysis']['priority'] == 'high' and r['estimated_effort'] == 'high']
    
    # Phase 3: Medium priority
    phase3 = [r for r in recommendations if r['analysis']['priority'] == 'medium']
    
    # Phase 4: Low priority
    phase4 = [r for r in recommendations if r['analysis']['priority'] == 'low']
    
    print(f"\nüéØ PHASE 1 - Quick Wins ({len(phase1)} files)")
    print("   High priority, manageable effort")
    for rec in sorted(phase1, key=lambda x: x['analysis']['total_methods'])[:8]:
        file_name = Path(rec['original_file']).name
        methods = rec['analysis']['total_methods']
        strategy = rec['analysis']['recommended_strategy']
        print(f"   ‚Ä¢ {file_name}: {methods} methods, {strategy}")
    
    print(f"\nüî• PHASE 2 - Major Refactoring ({len(phase2)} files)")
    print("   High priority, high effort - consider splitting")
    for rec in sorted(phase2, key=lambda x: x['analysis']['total_methods'], reverse=True)[:5]:
        file_name = Path(rec['original_file']).name
        methods = rec['analysis']['total_methods']
        should_split = rec['analysis']['should_split']
        split_indicator = " [SPLIT]" if should_split else ""
        print(f"   ‚Ä¢ {file_name}: {methods} methods{split_indicator}")
    
    print(f"\n‚è≥ PHASE 3 - Medium Priority ({len(phase3)} files)")
    print(f"‚ö° PHASE 4 - Low Priority ({len(phase4)} files)")

def print_specific_recommendations():
    """Print specific file-by-file recommendations"""
    print("\n" + "="*80)
    print("üìã TOP 10 SPECIFIC RECOMMENDATIONS")
    print("="*80)
    
    recommendations = [
        {
            "file": "test_transformer.py",
            "methods": 80,
            "action": "SPLIT into 5-6 files by functionality (renaming, removal, addition, etc.)",
            "structure": "Use data_transformation_*.json for each operation type",
            "priority": "üî¥ CRITICAL"
        },
        {
            "file": "test_tokenizer.py", 
            "methods": 41,
            "action": "SPLIT into token types (keywords, identifiers, operators, etc.)",
            "structure": "Use data_tokenize_*.json for each token category",
            "priority": "üî¥ CRITICAL"
        },
        {
            "file": "test_parser_comprehensive.py",
            "methods": 36,
            "action": "SPLIT into 7 focused test files by C language construct",
            "structure": "data_struct_parsing.json, data_enum_parsing.json, etc.",
            "priority": "üî¥ CRITICAL"
        },
        {
            "file": "test_generator.py",
            "methods": 20,
            "action": "Use data_generation_*.json for different output scenarios",
            "structure": "data_basic_generation.json, data_complex_generation.json",
            "priority": "üî¥ HIGH"
        },
        {
            "file": "test_preprocessor_bug.py",
            "methods": 19,
            "action": "Use data_preprocessor_*.json for different directive types",
            "structure": "data_ifdef.json, data_define.json, data_include.json",
            "priority": "üî¥ HIGH"
        },
        {
            "file": "test_invalid_source_paths.py",
            "methods": 17,
            "action": "Use data_path_error_*.json for different error scenarios",
            "structure": "data_missing_files.json, data_invalid_paths.json",
            "priority": "üî¥ HIGH"
        },
        {
            "file": "test_preprocessor_handling.py",
            "methods": 14,
            "action": "Use data_preprocessor_handling_*.json by directive type",
            "structure": "Group by conditional compilation, macro expansion",
            "priority": "üî¥ HIGH"
        },
        {
            "file": "test_anonymous_processor_extended.py",
            "methods": 14,
            "action": "Use data_anonymous_*.json for complexity levels",
            "structure": "data_simple_anonymous.json, data_nested_anonymous.json",
            "priority": "üî¥ HIGH"
        },
        {
            "file": "test_config.py",
            "methods": 13,
            "action": "Use data_config_*.json for different config scenarios",
            "structure": "data_basic_config.json, data_advanced_config.json",
            "priority": "üü° MEDIUM"
        },
        {
            "file": "test_include_filtering_bugs.py",
            "methods": 12,
            "action": "Use data_include_filter_*.json for filter patterns",
            "structure": "data_include_patterns.json, data_exclude_patterns.json",
            "priority": "üü° MEDIUM"
        }
    ]
    
    for i, rec in enumerate(recommendations, 1):
        print(f"\n{i:2d}. {rec['priority']} {rec['file']}")
        print(f"    üìä Methods: {rec['methods']}")
        print(f"    üéØ Action: {rec['action']}")
        print(f"    üìÅ Structure: {rec['structure']}")

def print_data_json_examples():
    """Print examples of data.json structures for different scenarios"""
    print("\n" + "="*80)
    print("üìù DATA.JSON EXAMPLES BY USE CASE")
    print("="*80)
    
    examples = {
        "Simple Struct Parsing": {
            "file": "data_simple_struct.json",
            "content": {
                "description": "Basic struct parsing test",
                "generate_type": "source_files",
                "files": {
                    "test.c": {
                        "content": "#include <stdio.h>\n\nstruct Point {\n    int x;\n    int y;\n};\n\nint main() {\n    struct Point p = {10, 20};\n    return 0;\n}"
                    }
                },
                "expected_elements": {
                    "structs": ["Point"],
                    "functions": ["main"]
                }
            }
        },
        "Preprocessor Conditional": {
            "file": "data_ifdef_test.json", 
            "content": {
                "description": "Conditional compilation test",
                "generate_type": "source_files",
                "files": {
                    "conditional.c": {
                        "content": "#ifdef DEBUG\n#define LOG(x) printf(x)\n#else\n#define LOG(x)\n#endif\n\nint main() {\n    LOG(\"Debug mode\");\n    return 0;\n}"
                    }
                },
                "config_overrides": {
                    "preprocessor_defines": ["DEBUG"]
                }
            }
        },
        "Complex Transformation": {
            "file": "data_rename_functions.json",
            "content": {
                "description": "Function renaming transformation test",
                "generate_type": "model_json",
                "model": {
                    "files": {
                        "main.c": {
                            "functions": [
                                {"name": "deprecated_init", "return_type": "void"},
                                {"name": "old_cleanup", "return_type": "void"}
                            ]
                        }
                    }
                },
                "config_overrides": {
                    "transformations": {
                        "rename": {
                            "functions": {
                                "^deprecated_(.*)": "legacy_\\1",
                                "^old_(.*)": "legacy_\\1"
                            }
                        }
                    }
                }
            }
        }
    }
    
    for title, example in examples.items():
        print(f"\nüìÑ {title} ({example['file']}):")
        content = json.dumps(example['content'], indent=2)
        # Show first few lines
        lines = content.split('\n')
        for line in lines[:15]:
            print(f"   {line}")
        if len(lines) > 15:
            print(f"   ... ({len(lines) - 15} more lines)")

def print_folder_structure_examples():
    """Print examples of recommended folder structures"""
    print("\n" + "="*80)
    print("üìÅ FOLDER STRUCTURE EXAMPLES")
    print("="*80)
    
    structures = [
        {
            "title": "Simple Test (Single Input)",
            "example": "test_generator_duplicate_includes",
            "structure": [
                "test_generator_duplicate_includes/",
                "‚îú‚îÄ‚îÄ test_generator_duplicate_includes.py",
                "‚îú‚îÄ‚îÄ input/",
                "‚îÇ   ‚îú‚îÄ‚îÄ config.json",
                "‚îÇ   ‚îú‚îÄ‚îÄ main.c",
                "‚îÇ   ‚îú‚îÄ‚îÄ utils.h",
                "‚îÇ   ‚îî‚îÄ‚îÄ types.h",
                "‚îî‚îÄ‚îÄ assertions.json"
            ]
        },
        {
            "title": "Multiple Scenarios (Data JSON)",
            "example": "test_parser_filtering",
            "structure": [
                "test_parser_filtering/",
                "‚îú‚îÄ‚îÄ test_parser_filtering.py", 
                "‚îú‚îÄ‚îÄ input/",
                "‚îÇ   ‚îú‚îÄ‚îÄ config.json",
                "‚îÇ   ‚îú‚îÄ‚îÄ data_include_patterns.json",
                "‚îÇ   ‚îú‚îÄ‚îÄ data_exclude_patterns.json",
                "‚îÇ   ‚îî‚îÄ‚îÄ data_mixed_filters.json",
                "‚îî‚îÄ‚îÄ assertions.json"
            ]
        },
        {
            "title": "Split Large Test",
            "example": "test_parser_comprehensive ‚Üí split",
            "structure": [
                "test_struct_parsing/",
                "‚îú‚îÄ‚îÄ test_struct_parsing.py",
                "‚îú‚îÄ‚îÄ input/",
                "‚îÇ   ‚îú‚îÄ‚îÄ config.json",
                "‚îÇ   ‚îú‚îÄ‚îÄ data_simple_struct.json",
                "‚îÇ   ‚îú‚îÄ‚îÄ data_nested_struct.json",
                "‚îÇ   ‚îî‚îÄ‚îÄ data_anonymous_struct.json",
                "‚îî‚îÄ‚îÄ assertions.json",
                "",
                "test_enum_parsing/",
                "‚îú‚îÄ‚îÄ test_enum_parsing.py",
                "‚îú‚îÄ‚îÄ input/",
                "‚îÇ   ‚îú‚îÄ‚îÄ config.json",
                "‚îÇ   ‚îú‚îÄ‚îÄ data_simple_enum.json",
                "‚îÇ   ‚îî‚îÄ‚îÄ data_typedef_enum.json",
                "‚îî‚îÄ‚îÄ assertions.json",
                "",
                "... (5 more split test folders)"
            ]
        }
    ]
    
    for struct in structures:
        print(f"\nüìÇ {struct['title']} - {struct['example']}")
        for line in struct['structure']:
            if line:
                print(f"   {line}")
            else:
                print()

def main():
    """Main function"""
    try:
        data = load_recommendations()
        recommendations = data["recommendations"]
        
        print_executive_summary(data)
        print_critical_findings(recommendations)
        print_strategy_breakdown(recommendations)
        print_migration_phases(recommendations)
        print_specific_recommendations()
        print_data_json_examples()
        print_folder_structure_examples()
        
        print("\n" + "="*80)
        print("‚úÖ NEXT STEPS")
        print("="*80)
        print("1. üèóÔ∏è  Implement TestDataFactory with data.json support")
        print("2. üîß Create TestExecutor for CLI-only testing")
        print("3. ‚úÖ Create validation framework (ModelValidator, etc.)")
        print("4. üöÄ Start with Phase 1 files (quick wins)")
        print("5. ‚úÇÔ∏è  Plan splitting strategy for large files")
        print("6. üìä Track progress in todo.md file")
        print()
        print("üìã See todo_recommendations.json for complete details")
        print("="*80)
        
    except FileNotFoundError:
        print("‚ùå Error: todo_recommendations.json not found!")
        print("Run python3 todo_recommendations.py first to generate recommendations.")

if __name__ == "__main__":
    main()