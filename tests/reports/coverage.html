<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Code Coverage Report</title>
    <style>
        body {
            font-family: sans-serif;
            background-color: #f9f9f9;
            padding: 2rem;
            max-width: 1200px;
            margin: 0 auto;
            line-height: 1.6;
            color: #333;
        }
        
        h1, h2, h3 {
            color: #2c3e50;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin: 2rem 0;
        }
        
        .stat {
            background: white;
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #3498db;
        }
        
        .file-section {
            background: white;
            margin: 1.5rem 0;
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .file-header {
            background: #34495e;
            color: white;
            padding: 0.75rem 1rem;
            margin: -1rem -1rem 1rem -1rem;
            border-radius: 8px 8px 0 0;
            font-weight: bold;
        }
        
        pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
            font-family: Consolas, Monaco, 'Courier New', monospace;
            font-size: 0.95rem;
            line-height: 1.5;
            margin: 1rem 0;
        }
        
        code {
            white-space: pre;
        }
        
        .line-number {
            color: #858585;
            margin-right: 1rem;
            user-select: none;
        }
        
        .covered {
            color: #4caf50;
        }
        
        .uncovered {
            color: #f44336;
        }
        
        .legend {
            background: white;
            padding: 1rem;
            border-radius: 8px;
            margin: 1.5rem 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 0.5rem 0;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 0.5rem;
            border-radius: 3px;
        }
        
        .footer {
            text-align: center;
            margin-top: 2rem;
            padding: 1rem;
            color: #7f8c8d;
            border-top: 1px solid #ecf0f1;
        }
    </style>
</head>
<body>
    <h1>Code Coverage Report</h1>
    <p>Generated on 2025-07-25 15:03:11</p>
<h1>ðŸ“Š Detailed Coverage Report</h1>
<p>This report shows all uncovered code lines with context, highlighting which lines are covered and which are not.</p>
<div class="stats">

    <div class="stat">
        <div class="stat-number">84.34%</div>
        <div class="stat-label">Total Coverage</div>
    </div>

    <div class="stat">
        <div class="stat-number">2,963</div>
        <div class="stat-label">Total Statements</div>
    </div>

    <div class="stat">
        <div class="stat-number">464</div>
        <div class="stat-label">Missing Statements</div>
    </div>

    <div class="stat">
        <div class="stat-number">10</div>
        <div class="stat-label">Files with Issues</div>
    </div>
</div>
<div class="legend">
<h3>Legend</h3>
<div class="legend-item">
<div class="legend-color" style="background-color: #4caf50;"></div>
<span>Covered lines: Code that was executed during testing</span>
</div>
<div class="legend-item">
<div class="legend-color" style="background-color: #f44336;"></div>
<span>Uncovered lines: Code that was not executed during testing</span>
</div>
<div class="legend-item">
<div class="legend-color" style="background-color: #858585;"></div>
<span>Context lines: Code before and after uncovered lines</span>
</div>
</div>
<div class="file-section">
<div class="file-header">
/workspace/c_to_plantuml/parser_tokenizer.py - 88.75% coverage (576/649 lines)
</div>
<h4>Line 222</h4>
<pre>
<span class="line-number">217</span>            if line_num &lt; total_lines:
<span class="line-number">218</span>                tokens.append(Token(TokenType.NEWLINE, &quot;\n&quot;, line_num, len(line)))
<span class="line-number">219</span>            line_num += 1
<span class="line-number">220</span>
<span class="line-number">221</span>        if in_multiline_string:
<span class="line-number">222</span><span class="uncovered">            tokens.append(</span>
<span class="line-number">223</span>                Token(
<span class="line-number">224</span>                    TokenType.STRING,
<span class="line-number">225</span>                    multiline_string_value,
<span class="line-number">226</span>                    multiline_string_start_line,
<span class="line-number">227</span>                    multiline_string_start_col,
</pre>
<h4>Line 231</h4>
<pre>
<span class="line-number">226</span>                    multiline_string_start_line,
<span class="line-number">227</span>                    multiline_string_start_col,
<span class="line-number">228</span>                )
<span class="line-number">229</span>            )
<span class="line-number">230</span>        if in_multiline_comment:
<span class="line-number">231</span><span class="uncovered">            tokens.append(</span>
<span class="line-number">232</span>                Token(
<span class="line-number">233</span>                    TokenType.COMMENT,
<span class="line-number">234</span>                    multiline_comment_value,
<span class="line-number">235</span>                    multiline_comment_start_line,
<span class="line-number">236</span>                    multiline_comment_start_col,
</pre>
<h4>Line 309</h4>
<pre>
<span class="line-number">304</span>                or (pos &gt; 1 and line[pos - 2 : pos] == &quot;u8&quot; and line[pos] == &#x27;&quot;&#x27;)
<span class="line-number">305</span>            ):
<span class="line-number">306</span>                # Handle string literals with possible prefixes
<span class="line-number">307</span>                string_start = pos
<span class="line-number">308</span>                if line[pos - 2 : pos] == &quot;u8&quot;:
<span class="line-number">309</span><span class="uncovered">                    string_start -= 2</span>
<span class="line-number">310</span>                elif line[pos - 1] in [&quot;L&quot;, &quot;u&quot;, &quot;U&quot;, &quot;R&quot;]:
<span class="line-number">311</span>                    string_start -= 1
<span class="line-number">312</span>                pos += 1  # Skip opening quote
<span class="line-number">313</span>                while pos &lt; len(line):
<span class="line-number">314</span>                    if line[pos] == &#x27;&quot;&#x27;:
</pre>
<h4>Line 311</h4>
<pre>
<span class="line-number">306</span>                # Handle string literals with possible prefixes
<span class="line-number">307</span>                string_start = pos
<span class="line-number">308</span>                if line[pos - 2 : pos] == &quot;u8&quot;:
<span class="line-number">309</span>                    string_start -= 2
<span class="line-number">310</span>                elif line[pos - 1] in [&quot;L&quot;, &quot;u&quot;, &quot;U&quot;, &quot;R&quot;]:
<span class="line-number">311</span><span class="uncovered">                    string_start -= 1</span>
<span class="line-number">312</span>                pos += 1  # Skip opening quote
<span class="line-number">313</span>                while pos &lt; len(line):
<span class="line-number">314</span>                    if line[pos] == &#x27;&quot;&#x27;:
<span class="line-number">315</span>                        # Found closing quote
<span class="line-number">316</span>                        string_text = line[string_start : pos + 1]
</pre>
<h4>Lines 413-414</h4>
<pre>
<span class="line-number">408</span>        while i &lt; len(tokens):
<span class="line-number">409</span>            token = tokens[i]
<span class="line-number">410</span>
<span class="line-number">411</span>            if token.type == TokenType.DEFINE and token.value.rstrip().endswith(&quot;\\&quot;):
<span class="line-number">412</span>                # Found a multi-line macro, merge with subsequent lines
<span class="line-number">413</span><span class="uncovered">                macro_content = token.value</span>
<span class="line-number">414</span><span class="uncovered">                current_line = token.line</span>
<span class="line-number">415</span>
<span class="line-number">416</span>                # Continue merging lines until we find one that doesn&#x27;t end with backslash
<span class="line-number">417</span>                while macro_content.rstrip().endswith(&quot;\\&quot;):
<span class="line-number">418</span>                    # Remove the backslash and add a newline
<span class="line-number">419</span>                    macro_content = macro_content.rstrip()[:-1] + &quot;\n&quot;
</pre>
<h4>Line 417</h4>
<pre>
<span class="line-number">412</span>                # Found a multi-line macro, merge with subsequent lines
<span class="line-number">413</span>                macro_content = token.value
<span class="line-number">414</span>                current_line = token.line
<span class="line-number">415</span>
<span class="line-number">416</span>                # Continue merging lines until we find one that doesn&#x27;t end with backslash
<span class="line-number">417</span><span class="uncovered">                while macro_content.rstrip().endswith(&quot;\\&quot;):</span>
<span class="line-number">418</span>                    # Remove the backslash and add a newline
<span class="line-number">419</span>                    macro_content = macro_content.rstrip()[:-1] + &quot;\n&quot;
<span class="line-number">420</span>                    current_line += 1
<span class="line-number">421</span>
<span class="line-number">422</span>                    # Find the next line content
</pre>
<h4>Lines 419-420</h4>
<pre>
<span class="line-number">414</span>                current_line = token.line
<span class="line-number">415</span>
<span class="line-number">416</span>                # Continue merging lines until we find one that doesn&#x27;t end with backslash
<span class="line-number">417</span>                while macro_content.rstrip().endswith(&quot;\\&quot;):
<span class="line-number">418</span>                    # Remove the backslash and add a newline
<span class="line-number">419</span><span class="uncovered">                    macro_content = macro_content.rstrip()[:-1] + &quot;\n&quot;</span>
<span class="line-number">420</span><span class="uncovered">                    current_line += 1</span>
<span class="line-number">421</span>
<span class="line-number">422</span>                    # Find the next line content
<span class="line-number">423</span>                    if current_line &lt;= len(lines):
<span class="line-number">424</span>                        next_line = lines[current_line - 1]
<span class="line-number">425</span>                        macro_content += next_line
</pre>
<h4>Lines 423-425</h4>
<pre>
<span class="line-number">418</span>                    # Remove the backslash and add a newline
<span class="line-number">419</span>                    macro_content = macro_content.rstrip()[:-1] + &quot;\n&quot;
<span class="line-number">420</span>                    current_line += 1
<span class="line-number">421</span>
<span class="line-number">422</span>                    # Find the next line content
<span class="line-number">423</span><span class="uncovered">                    if current_line &lt;= len(lines):</span>
<span class="line-number">424</span><span class="uncovered">                        next_line = lines[current_line - 1]</span>
<span class="line-number">425</span><span class="uncovered">                        macro_content += next_line</span>
<span class="line-number">426</span>                    else:
<span class="line-number">427</span>                        break
<span class="line-number">428</span>
<span class="line-number">429</span>                # Create a new token with the merged content
<span class="line-number">430</span>                merged_tokens.append(
</pre>
<h4>Line 427</h4>
<pre>
<span class="line-number">422</span>                    # Find the next line content
<span class="line-number">423</span>                    if current_line &lt;= len(lines):
<span class="line-number">424</span>                        next_line = lines[current_line - 1]
<span class="line-number">425</span>                        macro_content += next_line
<span class="line-number">426</span>                    else:
<span class="line-number">427</span><span class="uncovered">                        break</span>
<span class="line-number">428</span>
<span class="line-number">429</span>                # Create a new token with the merged content
<span class="line-number">430</span>                merged_tokens.append(
<span class="line-number">431</span>                    Token(TokenType.DEFINE, macro_content, token.line, token.column)
<span class="line-number">432</span>                )
</pre>
<h4>Line 430</h4>
<pre>
<span class="line-number">425</span>                        macro_content += next_line
<span class="line-number">426</span>                    else:
<span class="line-number">427</span>                        break
<span class="line-number">428</span>
<span class="line-number">429</span>                # Create a new token with the merged content
<span class="line-number">430</span><span class="uncovered">                merged_tokens.append(</span>
<span class="line-number">431</span>                    Token(TokenType.DEFINE, macro_content, token.line, token.column)
<span class="line-number">432</span>                )
<span class="line-number">433</span>            else:
<span class="line-number">434</span>                merged_tokens.append(token)
<span class="line-number">435</span>
</pre>
<h4>Lines 532-533</h4>
<pre>
<span class="line-number">527</span>        &quot;&quot;&quot;Check if current token is of specified type&quot;&quot;&quot;
<span class="line-number">528</span>        return self.pos &lt; len(self.tokens) and self.tokens[self.pos].type == token_type
<span class="line-number">529</span>
<span class="line-number">530</span>    def _peek_token(self, offset: int = 1) -&gt; Optional[Token]:
<span class="line-number">531</span>        &quot;&quot;&quot;Peek at token at current position + offset&quot;&quot;&quot;
<span class="line-number">532</span><span class="uncovered">        peek_pos = self.pos + offset</span>
<span class="line-number">533</span><span class="uncovered">        return self.tokens[peek_pos] if peek_pos &lt; len(self.tokens) else None</span>
<span class="line-number">534</span>
<span class="line-number">535</span>    def _advance(self) -&gt; Optional[Token]:
<span class="line-number">536</span>        &quot;&quot;&quot;Advance to next token and return current&quot;&quot;&quot;
<span class="line-number">537</span>        if self.pos &lt; len(self.tokens):
<span class="line-number">538</span>            token = self.tokens[self.pos]
</pre>
<h4>Line 541</h4>
<pre>
<span class="line-number">536</span>        &quot;&quot;&quot;Advance to next token and return current&quot;&quot;&quot;
<span class="line-number">537</span>        if self.pos &lt; len(self.tokens):
<span class="line-number">538</span>            token = self.tokens[self.pos]
<span class="line-number">539</span>            self.pos += 1
<span class="line-number">540</span>            return token
<span class="line-number">541</span><span class="uncovered">        return None</span>
<span class="line-number">542</span>
<span class="line-number">543</span>    def _find_matching_brace(self, start_pos: int) -&gt; Optional[int]:
<span class="line-number">544</span>        &quot;&quot;&quot;Find matching closing brace starting from open brace position&quot;&quot;&quot;
<span class="line-number">545</span>        if (
<span class="line-number">546</span>            start_pos &gt;= len(self.tokens)
</pre>
<h4>Line 549</h4>
<pre>
<span class="line-number">544</span>        &quot;&quot;&quot;Find matching closing brace starting from open brace position&quot;&quot;&quot;
<span class="line-number">545</span>        if (
<span class="line-number">546</span>            start_pos &gt;= len(self.tokens)
<span class="line-number">547</span>            or self.tokens[start_pos].type != TokenType.LBRACE
<span class="line-number">548</span>        ):
<span class="line-number">549</span><span class="uncovered">            return None</span>
<span class="line-number">550</span>
<span class="line-number">551</span>        depth = 1
<span class="line-number">552</span>        pos = start_pos + 1
<span class="line-number">553</span>
<span class="line-number">554</span>        while pos &lt; len(self.tokens) and depth &gt; 0:
</pre>
<h4>Line 569</h4>
<pre>
<span class="line-number">564</span>        &quot;&quot;&quot;Parse struct definition starting at current position&quot;&quot;&quot;
<span class="line-number">565</span>        start_pos = self.pos
<span class="line-number">566</span>
<span class="line-number">567</span>        # Consume &#x27;struct&#x27; keyword
<span class="line-number">568</span>        if not self._current_token_is(TokenType.STRUCT):
<span class="line-number">569</span><span class="uncovered">            return None</span>
<span class="line-number">570</span>        self._advance()
<span class="line-number">571</span>
<span class="line-number">572</span>        # Skip whitespace
<span class="line-number">573</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">574</span>            TokenType.WHITESPACE
</pre>
<h4>Line 597</h4>
<pre>
<span class="line-number">592</span>        # Find matching closing brace
<span class="line-number">593</span>        brace_pos = self.pos
<span class="line-number">594</span>        end_brace_pos = self._find_matching_brace(brace_pos)
<span class="line-number">595</span>
<span class="line-number">596</span>        if end_brace_pos is None:
<span class="line-number">597</span><span class="uncovered">            return None</span>
<span class="line-number">598</span>
<span class="line-number">599</span>        # Look for struct name after closing brace
<span class="line-number">600</span>        name_pos = end_brace_pos + 1
<span class="line-number">601</span>        struct_name = struct_tag  # Default to tag name
<span class="line-number">602</span>
</pre>
<h4>Line 654</h4>
<pre>
<span class="line-number">649</span>        &quot;&quot;&quot;Parse typedef struct definition&quot;&quot;&quot;
<span class="line-number">650</span>        start_pos = self.pos
<span class="line-number">651</span>
<span class="line-number">652</span>        # Consume &#x27;typedef&#x27;
<span class="line-number">653</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">654</span><span class="uncovered">            return None</span>
<span class="line-number">655</span>        self._advance()
<span class="line-number">656</span>
<span class="line-number">657</span>        # Look for &#x27;struct&#x27;
<span class="line-number">658</span>        if not self._current_token_is(TokenType.STRUCT):
<span class="line-number">659</span>            # Not a typedef struct, reset position
</pre>
<h4>Line 670</h4>
<pre>
<span class="line-number">665</span>
<span class="line-number">666</span>        # Skip whitespace
<span class="line-number">667</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">668</span>            TokenType.WHITESPACE
<span class="line-number">669</span>        ):
<span class="line-number">670</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">671</span>
<span class="line-number">672</span>        # Get struct tag name (optional)
<span class="line-number">673</span>        struct_tag = &quot;&quot;
<span class="line-number">674</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">675</span>            struct_tag = self._advance().value
</pre>
<h4>Line 681</h4>
<pre>
<span class="line-number">676</span>
<span class="line-number">677</span>        # Skip whitespace
<span class="line-number">678</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">679</span>            TokenType.WHITESPACE
<span class="line-number">680</span>        ):
<span class="line-number">681</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">682</span>
<span class="line-number">683</span>        # Check if this is a forward declaration (no braces)
<span class="line-number">684</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">685</span>            # This is a forward declaration like &quot;typedef struct Node* NodePtr;&quot;
<span class="line-number">686</span>            # Not a struct definition, so skip it
</pre>
<h4>Lines 693-694</h4>
<pre>
<span class="line-number">688</span>            return None
<span class="line-number">689</span>
<span class="line-number">690</span>        # Find matching closing brace
<span class="line-number">691</span>        end_brace_pos = self._find_matching_brace(self.pos)
<span class="line-number">692</span>        if end_brace_pos is None:
<span class="line-number">693</span><span class="uncovered">            self.pos = start_pos + 1</span>
<span class="line-number">694</span><span class="uncovered">            return None</span>
<span class="line-number">695</span>
<span class="line-number">696</span>        # Look for typedef name after closing brace
<span class="line-number">697</span>        typedef_name = &quot;&quot;
<span class="line-number">698</span>        name_pos = end_brace_pos + 1
<span class="line-number">699</span>        while name_pos &lt; len(self.tokens):
</pre>
<h4>Lines 703-705</h4>
<pre>
<span class="line-number">698</span>        name_pos = end_brace_pos + 1
<span class="line-number">699</span>        while name_pos &lt; len(self.tokens):
<span class="line-number">700</span>            if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">701</span>                typedef_name = self.tokens[name_pos].value
<span class="line-number">702</span>                break
<span class="line-number">703</span><span class="uncovered">            elif self.tokens[name_pos].type == TokenType.SEMICOLON:</span>
<span class="line-number">704</span><span class="uncovered">                break</span>
<span class="line-number">705</span><span class="uncovered">            name_pos += 1</span>
<span class="line-number">706</span>
<span class="line-number">707</span>        # Find semicolon
<span class="line-number">708</span>        while (
<span class="line-number">709</span>            name_pos &lt; len(self.tokens)
<span class="line-number">710</span>            and not self.tokens[name_pos].type == TokenType.SEMICOLON
</pre>
<h4>Line 723</h4>
<pre>
<span class="line-number">718</span>        &quot;&quot;&quot;Parse enum definition starting at current position&quot;&quot;&quot;
<span class="line-number">719</span>        start_pos = self.pos
<span class="line-number">720</span>
<span class="line-number">721</span>        # Consume &#x27;enum&#x27; keyword
<span class="line-number">722</span>        if not self._current_token_is(TokenType.ENUM):
<span class="line-number">723</span><span class="uncovered">            return None</span>
<span class="line-number">724</span>        self._advance()
<span class="line-number">725</span>
<span class="line-number">726</span>        # Skip whitespace
<span class="line-number">727</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">728</span>            TokenType.WHITESPACE
</pre>
<h4>Line 751</h4>
<pre>
<span class="line-number">746</span>        # Find matching closing brace
<span class="line-number">747</span>        brace_pos = self.pos
<span class="line-number">748</span>        end_brace_pos = self._find_matching_brace(brace_pos)
<span class="line-number">749</span>
<span class="line-number">750</span>        if end_brace_pos is None:
<span class="line-number">751</span><span class="uncovered">            return None</span>
<span class="line-number">752</span>
<span class="line-number">753</span>        # Look for enum name after closing brace
<span class="line-number">754</span>        name_pos = end_brace_pos + 1
<span class="line-number">755</span>        enum_name = enum_tag  # Default to tag name
<span class="line-number">756</span>
</pre>
<h4>Line 779</h4>
<pre>
<span class="line-number">774</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">775</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">776</span>                    enum_name = self.tokens[name_pos].value
<span class="line-number">777</span>                    break
<span class="line-number">778</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">779</span><span class="uncovered">                    break</span>
<span class="line-number">780</span>                name_pos += 1
<span class="line-number">781</span>        elif not enum_tag:
<span class="line-number">782</span>            # Anonymous enum - check if there&#x27;s a variable name after the brace
<span class="line-number">783</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">784</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
</pre>
<h4>Lines 788-790</h4>
<pre>
<span class="line-number">783</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">784</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">785</span>                    # This is a variable name, not an enum name
<span class="line-number">786</span>                    enum_name = &quot;&quot;
<span class="line-number">787</span>                    break
<span class="line-number">788</span><span class="uncovered">                elif self.tokens[name_pos].type == TokenType.SEMICOLON:</span>
<span class="line-number">789</span><span class="uncovered">                    break</span>
<span class="line-number">790</span><span class="uncovered">                name_pos += 1</span>
<span class="line-number">791</span>
<span class="line-number">792</span>        # Find semicolon
<span class="line-number">793</span>        self.pos = end_brace_pos + 1
<span class="line-number">794</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">795</span>            TokenType.SEMICOLON
</pre>
<h4>Line 808</h4>
<pre>
<span class="line-number">803</span>        &quot;&quot;&quot;Parse typedef enum definition&quot;&quot;&quot;
<span class="line-number">804</span>        start_pos = self.pos
<span class="line-number">805</span>
<span class="line-number">806</span>        # Consume &#x27;typedef&#x27;
<span class="line-number">807</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">808</span><span class="uncovered">            return None</span>
<span class="line-number">809</span>        self._advance()
<span class="line-number">810</span>
<span class="line-number">811</span>        # Look for &#x27;enum&#x27;
<span class="line-number">812</span>        if not self._current_token_is(TokenType.ENUM):
<span class="line-number">813</span>            # Not a typedef enum, reset position
</pre>
<h4>Lines 820-821</h4>
<pre>
<span class="line-number">815</span>            return None
<span class="line-number">816</span>
<span class="line-number">817</span>        # Parse the enum part - this will return the tag name (e.g., StatusEnum_tag)
<span class="line-number">818</span>        enum_info = self._parse_enum()
<span class="line-number">819</span>        if not enum_info:
<span class="line-number">820</span><span class="uncovered">            self.pos = start_pos + 1</span>
<span class="line-number">821</span><span class="uncovered">            return None</span>
<span class="line-number">822</span>
<span class="line-number">823</span>        # For typedef enums, we want to return the tag name, not the typedef name
<span class="line-number">824</span>        # The typedef name will be handled separately in the parser
<span class="line-number">825</span>        return enum_info
<span class="line-number">826</span>
</pre>
<h4>Line 946</h4>
<pre>
<span class="line-number">941</span>        return None
<span class="line-number">942</span>
<span class="line-number">943</span>    def _is_function_declaration(self, end_pos: int) -&gt; bool:
<span class="line-number">944</span>        &quot;&quot;&quot;Check if the function at end_pos is a declaration (ends with ;) or definition (ends with })&quot;&quot;&quot;
<span class="line-number">945</span>        if end_pos &gt;= len(self.tokens):
<span class="line-number">946</span><span class="uncovered">            return False</span>
<span class="line-number">947</span>
<span class="line-number">948</span>        # Look backwards from end_pos to find the last significant token
<span class="line-number">949</span>        pos = end_pos
<span class="line-number">950</span>        while pos &gt;= 0:
<span class="line-number">951</span>            token_type = self.tokens[pos].type
</pre>
<h4>Line 958</h4>
<pre>
<span class="line-number">953</span>                TokenType.WHITESPACE,
<span class="line-number">954</span>                TokenType.COMMENT,
<span class="line-number">955</span>                TokenType.NEWLINE,
<span class="line-number">956</span>            ]:
<span class="line-number">957</span>                return token_type == TokenType.SEMICOLON
<span class="line-number">958</span><span class="uncovered">            pos -= 1</span>
<span class="line-number">959</span>
<span class="line-number">960</span>        return False
<span class="line-number">961</span>
<span class="line-number">962</span>    def _find_function_end(self, start_pos: int) -&gt; Optional[int]:
<span class="line-number">963</span>        &quot;&quot;&quot;Find end of function declaration or definition&quot;&quot;&quot;
</pre>
<h4>Line 960</h4>
<pre>
<span class="line-number">955</span>                TokenType.NEWLINE,
<span class="line-number">956</span>            ]:
<span class="line-number">957</span>                return token_type == TokenType.SEMICOLON
<span class="line-number">958</span>            pos -= 1
<span class="line-number">959</span>
<span class="line-number">960</span><span class="uncovered">        return False</span>
<span class="line-number">961</span>
<span class="line-number">962</span>    def _find_function_end(self, start_pos: int) -&gt; Optional[int]:
<span class="line-number">963</span>        &quot;&quot;&quot;Find end of function declaration or definition&quot;&quot;&quot;
<span class="line-number">964</span>        pos = start_pos
<span class="line-number">965</span>
</pre>
<h4>Line 968</h4>
<pre>
<span class="line-number">963</span>        &quot;&quot;&quot;Find end of function declaration or definition&quot;&quot;&quot;
<span class="line-number">964</span>        pos = start_pos
<span class="line-number">965</span>
<span class="line-number">966</span>        # Find matching closing parenthesis
<span class="line-number">967</span>        if pos &gt;= len(self.tokens) or self.tokens[pos].type != TokenType.LPAREN:
<span class="line-number">968</span><span class="uncovered">            return None</span>
<span class="line-number">969</span>
<span class="line-number">970</span>        depth = 1
<span class="line-number">971</span>        pos += 1
<span class="line-number">972</span>
<span class="line-number">973</span>        while pos &lt; len(self.tokens) and depth &gt; 0:
</pre>
<h4>Line 993</h4>
<pre>
<span class="line-number">988</span>                # Function definition - find matching brace
<span class="line-number">989</span>                end_brace = self._find_matching_brace(pos)
<span class="line-number">990</span>                return end_brace if end_brace else pos
<span class="line-number">991</span>            pos += 1
<span class="line-number">992</span>
<span class="line-number">993</span><span class="uncovered">        return None</span>
<span class="line-number">994</span>
<span class="line-number">995</span>    def _parse_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">996</span>        &quot;&quot;&quot;Parse union definition&quot;&quot;&quot;
<span class="line-number">997</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">998</span>            return None
</pre>
<h4>Line 998</h4>
<pre>
<span class="line-number">993</span>        return None
<span class="line-number">994</span>
<span class="line-number">995</span>    def _parse_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">996</span>        &quot;&quot;&quot;Parse union definition&quot;&quot;&quot;
<span class="line-number">997</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">998</span><span class="uncovered">            return None</span>
<span class="line-number">999</span>
<span class="line-number">1000</span>        start_pos = self.pos
<span class="line-number">1001</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1002</span>
<span class="line-number">1003</span>        # Skip whitespace
</pre>
<h4>Line 1007</h4>
<pre>
<span class="line-number">1002</span>
<span class="line-number">1003</span>        # Skip whitespace
<span class="line-number">1004</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1005</span>            TokenType.WHITESPACE
<span class="line-number">1006</span>        ):
<span class="line-number">1007</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Get union tag name (optional for anonymous unions)
<span class="line-number">1010</span>        union_tag = &quot;&quot;
<span class="line-number">1011</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1012</span>            union_tag = self._advance().value
</pre>
<h4>Line 1026</h4>
<pre>
<span class="line-number">1021</span>            return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>        # Find matching closing brace
<span class="line-number">1024</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1025</span>        if end_pos is None:
<span class="line-number">1026</span><span class="uncovered">            return None</span>
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Look for union name after closing brace (for typedefs or named unions)
<span class="line-number">1029</span>        union_name = union_tag  # Default to tag name
<span class="line-number">1030</span>
<span class="line-number">1031</span>        # Skip to semicolon
</pre>
<h4>Lines 1036-1039</h4>
<pre>
<span class="line-number">1031</span>        # Skip to semicolon
<span class="line-number">1032</span>        self.pos = end_pos + 1
<span class="line-number">1033</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1034</span>            TokenType.SEMICOLON
<span class="line-number">1035</span>        ):
<span class="line-number">1036</span><span class="uncovered">            if self._current_token_is(TokenType.IDENTIFIER):</span>
<span class="line-number">1037</span><span class="uncovered">                union_name = self._advance().value</span>
<span class="line-number">1038</span><span class="uncovered">                break</span>
<span class="line-number">1039</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1040</span>
<span class="line-number">1041</span>        return (start_pos, end_pos, union_name)
<span class="line-number">1042</span>
<span class="line-number">1043</span>    def _parse_typedef_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">1044</span>        &quot;&quot;&quot;Parse typedef union definition&quot;&quot;&quot;
</pre>
<h4>Line 1046</h4>
<pre>
<span class="line-number">1041</span>        return (start_pos, end_pos, union_name)
<span class="line-number">1042</span>
<span class="line-number">1043</span>    def _parse_typedef_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">1044</span>        &quot;&quot;&quot;Parse typedef union definition&quot;&quot;&quot;
<span class="line-number">1045</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">1046</span><span class="uncovered">            return None</span>
<span class="line-number">1047</span>
<span class="line-number">1048</span>        start_pos = self.pos
<span class="line-number">1049</span>        self._advance()  # Consumes &#x27;typedef&#x27;
<span class="line-number">1050</span>
<span class="line-number">1051</span>        # Skip whitespace
</pre>
<h4>Line 1055</h4>
<pre>
<span class="line-number">1050</span>
<span class="line-number">1051</span>        # Skip whitespace
<span class="line-number">1052</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1053</span>            TokenType.WHITESPACE
<span class="line-number">1054</span>        ):
<span class="line-number">1055</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1056</span>
<span class="line-number">1057</span>        # Check if next token is &#x27;union&#x27;
<span class="line-number">1058</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">1059</span>            return None
<span class="line-number">1060</span>
</pre>
<h4>Line 1067</h4>
<pre>
<span class="line-number">1062</span>
<span class="line-number">1063</span>        # Skip whitespace
<span class="line-number">1064</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1065</span>            TokenType.WHITESPACE
<span class="line-number">1066</span>        ):
<span class="line-number">1067</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1068</span>
<span class="line-number">1069</span>        # Get union tag name (optional)
<span class="line-number">1070</span>        union_tag = &quot;&quot;
<span class="line-number">1071</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1072</span>            union_tag = self._advance().value
</pre>
<h4>Line 1072</h4>
<pre>
<span class="line-number">1067</span>            self.pos += 1
<span class="line-number">1068</span>
<span class="line-number">1069</span>        # Get union tag name (optional)
<span class="line-number">1070</span>        union_tag = &quot;&quot;
<span class="line-number">1071</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1072</span><span class="uncovered">            union_tag = self._advance().value</span>
<span class="line-number">1073</span>
<span class="line-number">1074</span>        # Find opening brace
<span class="line-number">1075</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1076</span>            TokenType.LBRACE
<span class="line-number">1077</span>        ):
</pre>
<h4>Line 1078</h4>
<pre>
<span class="line-number">1073</span>
<span class="line-number">1074</span>        # Find opening brace
<span class="line-number">1075</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1076</span>            TokenType.LBRACE
<span class="line-number">1077</span>        ):
<span class="line-number">1078</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1079</span>
<span class="line-number">1080</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1081</span>            return None
<span class="line-number">1082</span>
<span class="line-number">1083</span>        # Find matching closing brace
</pre>
<h4>Line 1081</h4>
<pre>
<span class="line-number">1076</span>            TokenType.LBRACE
<span class="line-number">1077</span>        ):
<span class="line-number">1078</span>            self.pos += 1
<span class="line-number">1079</span>
<span class="line-number">1080</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1081</span><span class="uncovered">            return None</span>
<span class="line-number">1082</span>
<span class="line-number">1083</span>        # Find matching closing brace
<span class="line-number">1084</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1085</span>        if end_pos is None:
<span class="line-number">1086</span>            return None
</pre>
<h4>Line 1086</h4>
<pre>
<span class="line-number">1081</span>            return None
<span class="line-number">1082</span>
<span class="line-number">1083</span>        # Find matching closing brace
<span class="line-number">1084</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1085</span>        if end_pos is None:
<span class="line-number">1086</span><span class="uncovered">            return None</span>
<span class="line-number">1087</span>
<span class="line-number">1088</span>        # Look for typedef name after closing brace
<span class="line-number">1089</span>        typedef_name = &quot;&quot;
<span class="line-number">1090</span>        self.pos = end_pos + 1
<span class="line-number">1091</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
</pre>
<h4>Line 1097</h4>
<pre>
<span class="line-number">1092</span>            TokenType.SEMICOLON
<span class="line-number">1093</span>        ):
<span class="line-number">1094</span>            if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1095</span>                typedef_name = self._advance().value
<span class="line-number">1096</span>                break
<span class="line-number">1097</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return (start_pos, end_pos, typedef_name)
<span class="line-number">1100</span>
<span class="line-number">1101</span>
<span class="line-number">1102</span>def extract_token_range(tokens: List[Token], start: int, end: int) -&gt; str:
</pre>
<h4>Line 1126</h4>
<pre>
<span class="line-number">1121</span>    fields = []
<span class="line-number">1122</span>    pos = struct_start
<span class="line-number">1123</span>    while pos &lt;= struct_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1124</span>        pos += 1
<span class="line-number">1125</span>    if pos &gt; struct_end:
<span class="line-number">1126</span><span class="uncovered">        return fields</span>
<span class="line-number">1127</span>    pos += 1  # Skip opening brace
<span class="line-number">1128</span>
<span class="line-number">1129</span>    # Find the closing brace position
<span class="line-number">1130</span>    closing_brace_pos = pos
<span class="line-number">1131</span>    while (
</pre>
<h4>Line 1155</h4>
<pre>
<span class="line-number">1150</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1151</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1152</span>            ):
<span class="line-number">1153</span>                # This is a nested anonymous struct
<span class="line-number">1154</span>                # Find the struct name (last token before semicolon)
<span class="line-number">1155</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1156</span>                # Create a simplified type representation for nested struct
<span class="line-number">1157</span>                field_type = &quot;struct { ... }&quot;
<span class="line-number">1158</span>                if (
<span class="line-number">1159</span>                    field_name
<span class="line-number">1160</span>                    and field_name.strip()
</pre>
<h4>Lines 1157-1158</h4>
<pre>
<span class="line-number">1152</span>            ):
<span class="line-number">1153</span>                # This is a nested anonymous struct
<span class="line-number">1154</span>                # Find the struct name (last token before semicolon)
<span class="line-number">1155</span>                field_name = field_tokens[-1].value
<span class="line-number">1156</span>                # Create a simplified type representation for nested struct
<span class="line-number">1157</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1158</span><span class="uncovered">                if (</span>
<span class="line-number">1159</span>                    field_name
<span class="line-number">1160</span>                    and field_name.strip()
<span class="line-number">1161</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1162</span>                ):
<span class="line-number">1163</span>                    stripped_name = field_name.strip()
</pre>
<h4>Lines 1163-1165</h4>
<pre>
<span class="line-number">1158</span>                if (
<span class="line-number">1159</span>                    field_name
<span class="line-number">1160</span>                    and field_name.strip()
<span class="line-number">1161</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1162</span>                ):
<span class="line-number">1163</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1164</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1165</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1166</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1167</span>                        continue
<span class="line-number">1168</span>            # Check if this is a nested struct field with more complex structure
<span class="line-number">1169</span>            elif (
<span class="line-number">1170</span>                len(field_tokens) &gt;= 4
</pre>
<h4>Line 1167</h4>
<pre>
<span class="line-number">1162</span>                ):
<span class="line-number">1163</span>                    stripped_name = field_name.strip()
<span class="line-number">1164</span>                    if stripped_name:
<span class="line-number">1165</span>                        fields.append((stripped_name, field_type))
<span class="line-number">1166</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1167</span><span class="uncovered">                        continue</span>
<span class="line-number">1168</span>            # Check if this is a nested struct field with more complex structure
<span class="line-number">1169</span>            elif (
<span class="line-number">1170</span>                len(field_tokens) &gt;= 4
<span class="line-number">1171</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1172</span>                and field_tokens[1].type == TokenType.LBRACE
</pre>
<h4>Lines 1176-1178</h4>
<pre>
<span class="line-number">1171</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1172</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1173</span>                and field_tokens[-1].type == TokenType.IDENTIFIER
<span class="line-number">1174</span>            ):
<span class="line-number">1175</span>                # This is a nested anonymous struct with a name
<span class="line-number">1176</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1177</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1178</span><span class="uncovered">                if (</span>
<span class="line-number">1179</span>                    field_name
<span class="line-number">1180</span>                    and field_name.strip()
<span class="line-number">1181</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1182</span>                ):
<span class="line-number">1183</span>                    stripped_name = field_name.strip()
</pre>
<h4>Lines 1183-1185</h4>
<pre>
<span class="line-number">1178</span>                if (
<span class="line-number">1179</span>                    field_name
<span class="line-number">1180</span>                    and field_name.strip()
<span class="line-number">1181</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1182</span>                ):
<span class="line-number">1183</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1184</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1185</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1186</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1187</span>                        continue
<span class="line-number">1188</span>            # Array field: type name [ size ]
<span class="line-number">1189</span>            elif (
<span class="line-number">1190</span>                len(field_tokens) &gt;= 4
</pre>
<h4>Line 1187</h4>
<pre>
<span class="line-number">1182</span>                ):
<span class="line-number">1183</span>                    stripped_name = field_name.strip()
<span class="line-number">1184</span>                    if stripped_name:
<span class="line-number">1185</span>                        fields.append((stripped_name, field_type))
<span class="line-number">1186</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1187</span><span class="uncovered">                        continue</span>
<span class="line-number">1188</span>            # Array field: type name [ size ]
<span class="line-number">1189</span>            elif (
<span class="line-number">1190</span>                len(field_tokens) &gt;= 4
<span class="line-number">1191</span>                and field_tokens[-3].type == TokenType.LBRACKET
<span class="line-number">1192</span>                and field_tokens[-1].type == TokenType.RBRACKET
</pre>
<h4>Line 1240</h4>
<pre>
<span class="line-number">1235</span>    values = []
<span class="line-number">1236</span>    pos = enum_start
<span class="line-number">1237</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1238</span>        pos += 1
<span class="line-number">1239</span>    if pos &gt; enum_end:
<span class="line-number">1240</span><span class="uncovered">        return values</span>
<span class="line-number">1241</span>    pos += 1  # Skip opening brace
<span class="line-number">1242</span>    current_value = []
<span class="line-number">1243</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1244</span>        token = tokens[pos]
<span class="line-number">1245</span>        if token.type == TokenType.COMMA:
</pre>
</div>
<div class="file-section">
<div class="file-header">
/workspace/c_to_plantuml/generator.py - 85.91% coverage (250/291 lines)
</div>
<h4>Line 79</h4>
<pre>
<span class="line-number"> 74</span>                return file_name
<span class="line-number"> 75</span>
<span class="line-number"> 76</span>            # Try matching by filename
<span class="line-number"> 77</span>            filename = Path(file_name).name
<span class="line-number"> 78</span>            if filename in project_model.files:
<span class="line-number"> 79</span><span class="uncovered">                return filename</span>
<span class="line-number"> 80</span>
<span class="line-number"> 81</span>            # Try matching by relative path
<span class="line-number"> 82</span>            for key in project_model.files.keys():
<span class="line-number"> 83</span>                if Path(key).name == filename:
<span class="line-number"> 84</span>                    return key
</pre>
<h4>Line 91</h4>
<pre>
<span class="line-number"> 86</span>            # If not found, return the filename (will be handled gracefully)
<span class="line-number"> 87</span>            return filename
<span class="line-number"> 88</span>
<span class="line-number"> 89</span>        def add_file_to_tree(file_name: str, depth: int):
<span class="line-number"> 90</span>            if depth &gt; include_depth or file_name in visited:
<span class="line-number"> 91</span><span class="uncovered">                return</span>
<span class="line-number"> 92</span>
<span class="line-number"> 93</span>            visited.add(file_name)
<span class="line-number"> 94</span>            file_key = find_file_key(file_name)
<span class="line-number"> 95</span>
<span class="line-number"> 96</span>            if file_key in project_model.files:
</pre>
<h4>Line 152</h4>
<pre>
<span class="line-number">147</span>        # Find the UML ID for this file using filename
<span class="line-number">148</span>        filename = Path(file_model.relative_path).name
<span class="line-number">149</span>        uml_id = uml_ids.get(filename)
<span class="line-number">150</span>
<span class="line-number">151</span>        if not uml_id:
<span class="line-number">152</span><span class="uncovered">            return  # Skip if no UML ID found</span>
<span class="line-number">153</span>
<span class="line-number">154</span>        lines.append(f&#x27;class &quot;{basename}&quot; as {uml_id} &lt;&lt;source&gt;&gt; #LightBlue&#x27;)
<span class="line-number">155</span>        lines.append(&quot;{&quot;)
<span class="line-number">156</span>
<span class="line-number">157</span>        # Add macros
</pre>
<h4>Lines 163-165</h4>
<pre>
<span class="line-number">158</span>        if file_model.macros:
<span class="line-number">159</span>            lines.append(&quot;    -- Macros --&quot;)
<span class="line-number">160</span>            for macro in sorted(file_model.macros):
<span class="line-number">161</span>                if &quot;(&quot; in macro and &quot;)&quot; in macro:
<span class="line-number">162</span>                    # Function-like macro
<span class="line-number">163</span><span class="uncovered">                    macro_name = macro.split(&quot;(&quot;)[0].replace(&quot;#define &quot;, &quot;&quot;)</span>
<span class="line-number">164</span><span class="uncovered">                    params = macro.split(&quot;(&quot;)[1].split(&quot;)&quot;)[0]</span>
<span class="line-number">165</span><span class="uncovered">                    lines.append(f&quot;    - #define {macro_name}({params})&quot;)</span>
<span class="line-number">166</span>                else:
<span class="line-number">167</span>                    # Simple macro
<span class="line-number">168</span>                    macro_name = macro.replace(&quot;#define &quot;, &quot;&quot;)
<span class="line-number">169</span>                    lines.append(f&quot;    - #define {macro_name}&quot;)
<span class="line-number">170</span>
</pre>
<h4>Line 185</h4>
<pre>
<span class="line-number">180</span>            for func in sorted(file_model.functions, key=lambda x: x.name):
<span class="line-number">181</span>                if not func.is_declaration:  # Only implementation, not declarations
<span class="line-number">182</span>                    params = []
<span class="line-number">183</span>                    for p in func.parameters:
<span class="line-number">184</span>                        if p.name == &quot;...&quot; and p.type == &quot;...&quot;:
<span class="line-number">185</span><span class="uncovered">                            params.append(&quot;...&quot;)</span>
<span class="line-number">186</span>                        else:
<span class="line-number">187</span>                            params.append(f&quot;{p.type} {p.name}&quot;)
<span class="line-number">188</span>                    param_str = &quot;, &quot;.join(params)
<span class="line-number">189</span>                    lines.append(f&quot;    {func.return_type} {func.name}({param_str})&quot;)
<span class="line-number">190</span>
</pre>
<h4>Line 205</h4>
<pre>
<span class="line-number">200</span>        # Find the UML ID for this file using filename
<span class="line-number">201</span>        filename = Path(file_model.relative_path).name
<span class="line-number">202</span>        uml_id = uml_ids.get(filename)
<span class="line-number">203</span>
<span class="line-number">204</span>        if not uml_id:
<span class="line-number">205</span><span class="uncovered">            return  # Skip if no UML ID found</span>
<span class="line-number">206</span>
<span class="line-number">207</span>        lines.append(f&#x27;class &quot;{basename}&quot; as {uml_id} &lt;&lt;header&gt;&gt; #LightGreen&#x27;)
<span class="line-number">208</span>        lines.append(&quot;{&quot;)
<span class="line-number">209</span>
<span class="line-number">210</span>        # Add macros
</pre>
<h4>Lines 216-218</h4>
<pre>
<span class="line-number">211</span>        if file_model.macros:
<span class="line-number">212</span>            lines.append(&quot;    -- Macros --&quot;)
<span class="line-number">213</span>            for macro in sorted(file_model.macros):
<span class="line-number">214</span>                if &quot;(&quot; in macro and &quot;)&quot; in macro:
<span class="line-number">215</span>                    # Function-like macro
<span class="line-number">216</span><span class="uncovered">                    macro_name = macro.split(&quot;(&quot;)[0].replace(&quot;#define &quot;, &quot;&quot;)</span>
<span class="line-number">217</span><span class="uncovered">                    params = macro.split(&quot;(&quot;)[1].split(&quot;)&quot;)[0]</span>
<span class="line-number">218</span><span class="uncovered">                    lines.append(f&quot;    + #define {macro_name}({params})&quot;)</span>
<span class="line-number">219</span>                else:
<span class="line-number">220</span>                    # Simple macro
<span class="line-number">221</span>                    macro_name = macro.replace(&quot;#define &quot;, &quot;&quot;)
<span class="line-number">222</span>                    lines.append(f&quot;    + #define {macro_name}&quot;)
<span class="line-number">223</span>
</pre>
<h4>Line 274</h4>
<pre>
<span class="line-number">269</span>                    f&#x27;class &quot;{enum_name}&quot; as {uml_id} &lt;&lt;typedef&gt;&gt; #LightYellow&#x27;
<span class="line-number">270</span>                )
<span class="line-number">271</span>                lines.append(&quot;{&quot;)
<span class="line-number">272</span>                for value in sorted(enum_data.values, key=lambda x: x.name):
<span class="line-number">273</span>                    if value.value:
<span class="line-number">274</span><span class="uncovered">                        lines.append(f&quot;    + {value.name} = {value.value}&quot;)</span>
<span class="line-number">275</span>                    else:
<span class="line-number">276</span>                        lines.append(f&quot;    + {value.name}&quot;)
<span class="line-number">277</span>                lines.append(&quot;}&quot;)
<span class="line-number">278</span>                lines.append(&quot;&quot;)
<span class="line-number">279</span>
</pre>
<h4>Line 298</h4>
<pre>
<span class="line-number">293</span>                for i, line in enumerate(alias_lines):
<span class="line-number">294</span>                    line = line.strip()
<span class="line-number">295</span>
<span class="line-number">296</span>                    if i == 0:
<span class="line-number">297</span>                        lines.append(f&quot;    + {line}&quot;)
<span class="line-number">298</span><span class="uncovered">                    elif line.startswith(&quot;struct {&quot;):</span>
<span class="line-number">299</span>                        # Start collecting nested struct content
<span class="line-number">300</span>                        inside_struct = True
<span class="line-number">301</span>                        nested_content = []
<span class="line-number">302</span>                    elif line == &quot;}&quot;:
<span class="line-number">303</span>                        if inside_struct:
</pre>
<h4>Lines 300-303</h4>
<pre>
<span class="line-number">295</span>
<span class="line-number">296</span>                    if i == 0:
<span class="line-number">297</span>                        lines.append(f&quot;    + {line}&quot;)
<span class="line-number">298</span>                    elif line.startswith(&quot;struct {&quot;):
<span class="line-number">299</span>                        # Start collecting nested struct content
<span class="line-number">300</span><span class="uncovered">                        inside_struct = True</span>
<span class="line-number">301</span><span class="uncovered">                        nested_content = []</span>
<span class="line-number">302</span><span class="uncovered">                    elif line == &quot;}&quot;:</span>
<span class="line-number">303</span><span class="uncovered">                        if inside_struct:</span>
<span class="line-number">304</span>                            # Close nested struct with flattened content
<span class="line-number">305</span>                            if nested_content:
<span class="line-number">306</span>                                content_str = &quot;; &quot;.join(nested_content)
<span class="line-number">307</span>                                lines.append(f&quot;    + struct {{ {content_str} }}&quot;)
<span class="line-number">308</span>                            else:
</pre>
<h4>Lines 305-307</h4>
<pre>
<span class="line-number">300</span>                        inside_struct = True
<span class="line-number">301</span>                        nested_content = []
<span class="line-number">302</span>                    elif line == &quot;}&quot;:
<span class="line-number">303</span>                        if inside_struct:
<span class="line-number">304</span>                            # Close nested struct with flattened content
<span class="line-number">305</span><span class="uncovered">                            if nested_content:</span>
<span class="line-number">306</span><span class="uncovered">                                content_str = &quot;; &quot;.join(nested_content)</span>
<span class="line-number">307</span><span class="uncovered">                                lines.append(f&quot;    + struct {{ {content_str} }}&quot;)</span>
<span class="line-number">308</span>                            else:
<span class="line-number">309</span>                                lines.append(f&quot;    + struct {{ }}&quot;)
<span class="line-number">310</span>                            inside_struct = False
<span class="line-number">311</span>                            nested_content = []
<span class="line-number">312</span>                        else:
</pre>
<h4>Lines 309-311</h4>
<pre>
<span class="line-number">304</span>                            # Close nested struct with flattened content
<span class="line-number">305</span>                            if nested_content:
<span class="line-number">306</span>                                content_str = &quot;; &quot;.join(nested_content)
<span class="line-number">307</span>                                lines.append(f&quot;    + struct {{ {content_str} }}&quot;)
<span class="line-number">308</span>                            else:
<span class="line-number">309</span><span class="uncovered">                                lines.append(f&quot;    + struct {{ }}&quot;)</span>
<span class="line-number">310</span><span class="uncovered">                            inside_struct = False</span>
<span class="line-number">311</span><span class="uncovered">                            nested_content = []</span>
<span class="line-number">312</span>                        else:
<span class="line-number">313</span>                            lines.append(f&quot;    }}&quot;)
<span class="line-number">314</span>                    elif line and line != &quot;}&quot;:
<span class="line-number">315</span>                        if inside_struct:
<span class="line-number">316</span>                            nested_content.append(line)  # Collect nested content
</pre>
<h4>Lines 313-316</h4>
<pre>
<span class="line-number">308</span>                            else:
<span class="line-number">309</span>                                lines.append(f&quot;    + struct {{ }}&quot;)
<span class="line-number">310</span>                            inside_struct = False
<span class="line-number">311</span>                            nested_content = []
<span class="line-number">312</span>                        else:
<span class="line-number">313</span><span class="uncovered">                            lines.append(f&quot;    }}&quot;)</span>
<span class="line-number">314</span><span class="uncovered">                    elif line and line != &quot;}&quot;:</span>
<span class="line-number">315</span><span class="uncovered">                        if inside_struct:</span>
<span class="line-number">316</span><span class="uncovered">                            nested_content.append(line)  # Collect nested content</span>
<span class="line-number">317</span>                        else:
<span class="line-number">318</span>                            lines.append(f&quot;+ {line}&quot;)
<span class="line-number">319</span>
<span class="line-number">320</span>                # If we were inside a struct but didn&#x27;t find a closing brace, add one
<span class="line-number">321</span>                if inside_struct and nested_content:
</pre>
<h4>Line 318</h4>
<pre>
<span class="line-number">313</span>                            lines.append(f&quot;    }}&quot;)
<span class="line-number">314</span>                    elif line and line != &quot;}&quot;:
<span class="line-number">315</span>                        if inside_struct:
<span class="line-number">316</span>                            nested_content.append(line)  # Collect nested content
<span class="line-number">317</span>                        else:
<span class="line-number">318</span><span class="uncovered">                            lines.append(f&quot;+ {line}&quot;)</span>
<span class="line-number">319</span>
<span class="line-number">320</span>                # If we were inside a struct but didn&#x27;t find a closing brace, add one
<span class="line-number">321</span>                if inside_struct and nested_content:
<span class="line-number">322</span>                    content_str = &quot;; &quot;.join(nested_content)
<span class="line-number">323</span>                    lines.append(f&quot;    + struct {{ {content_str} }}&quot;)
</pre>
<h4>Lines 322-323</h4>
<pre>
<span class="line-number">317</span>                        else:
<span class="line-number">318</span>                            lines.append(f&quot;+ {line}&quot;)
<span class="line-number">319</span>
<span class="line-number">320</span>                # If we were inside a struct but didn&#x27;t find a closing brace, add one
<span class="line-number">321</span>                if inside_struct and nested_content:
<span class="line-number">322</span><span class="uncovered">                    content_str = &quot;; &quot;.join(nested_content)</span>
<span class="line-number">323</span><span class="uncovered">                    lines.append(f&quot;    + struct {{ {content_str} }}&quot;)</span>
<span class="line-number">324</span>                lines.append(&quot;}&quot;)
<span class="line-number">325</span>                lines.append(&quot;&quot;)
<span class="line-number">326</span>
<span class="line-number">327</span>        # Unions
<span class="line-number">328</span>        for union_name, union_data in sorted(file_model.unions.items()):
</pre>
<h4>Line 347</h4>
<pre>
<span class="line-number">342</span>        field_text = f&quot;{field.type} {field.name}&quot;
<span class="line-number">343</span>
<span class="line-number">344</span>        # Check if this is a nested struct field
<span class="line-number">345</span>        if field.type.startswith(&quot;struct {&quot;) and &#x27;\n&#x27; in field.type:
<span class="line-number">346</span>            # Parse the nested struct content and flatten it
<span class="line-number">347</span><span class="uncovered">            struct_parts = field.type.split(&#x27;\n&#x27;)</span>
<span class="line-number">348</span>
<span class="line-number">349</span>            # For nested structs, flatten them to avoid PlantUML parsing issues
<span class="line-number">350</span>            # Format as: + struct { field_type field_name }
<span class="line-number">351</span>            nested_content = []
<span class="line-number">352</span>            for part in struct_parts[1:]:
</pre>
<h4>Lines 351-355</h4>
<pre>
<span class="line-number">346</span>            # Parse the nested struct content and flatten it
<span class="line-number">347</span>            struct_parts = field.type.split(&#x27;\n&#x27;)
<span class="line-number">348</span>
<span class="line-number">349</span>            # For nested structs, flatten them to avoid PlantUML parsing issues
<span class="line-number">350</span>            # Format as: + struct { field_type field_name }
<span class="line-number">351</span><span class="uncovered">            nested_content = []</span>
<span class="line-number">352</span><span class="uncovered">            for part in struct_parts[1:]:</span>
<span class="line-number">353</span><span class="uncovered">                part = part.strip()</span>
<span class="line-number">354</span><span class="uncovered">                if part and part != &quot;}&quot;:</span>
<span class="line-number">355</span><span class="uncovered">                    nested_content.append(part)</span>
<span class="line-number">356</span>
<span class="line-number">357</span>            if nested_content:
<span class="line-number">358</span>                # Create a flattened representation
<span class="line-number">359</span>                content_str = &quot;; &quot;.join(nested_content)
<span class="line-number">360</span>                lines.append(f&quot;{base_indent}+ struct {{ {content_str} }} {field.name}&quot;)
</pre>
<h4>Line 357</h4>
<pre>
<span class="line-number">352</span>            for part in struct_parts[1:]:
<span class="line-number">353</span>                part = part.strip()
<span class="line-number">354</span>                if part and part != &quot;}&quot;:
<span class="line-number">355</span>                    nested_content.append(part)
<span class="line-number">356</span>
<span class="line-number">357</span><span class="uncovered">            if nested_content:</span>
<span class="line-number">358</span>                # Create a flattened representation
<span class="line-number">359</span>                content_str = &quot;; &quot;.join(nested_content)
<span class="line-number">360</span>                lines.append(f&quot;{base_indent}+ struct {{ {content_str} }} {field.name}&quot;)
<span class="line-number">361</span>            else:
<span class="line-number">362</span>                lines.append(f&quot;{base_indent}+ struct {{ }} {field.name}&quot;)
</pre>
<h4>Lines 359-360</h4>
<pre>
<span class="line-number">354</span>                if part and part != &quot;}&quot;:
<span class="line-number">355</span>                    nested_content.append(part)
<span class="line-number">356</span>
<span class="line-number">357</span>            if nested_content:
<span class="line-number">358</span>                # Create a flattened representation
<span class="line-number">359</span><span class="uncovered">                content_str = &quot;; &quot;.join(nested_content)</span>
<span class="line-number">360</span><span class="uncovered">                lines.append(f&quot;{base_indent}+ struct {{ {content_str} }} {field.name}&quot;)</span>
<span class="line-number">361</span>            else:
<span class="line-number">362</span>                lines.append(f&quot;{base_indent}+ struct {{ }} {field.name}&quot;)
<span class="line-number">363</span>        else:
<span class="line-number">364</span>            # Handle regular multi-line field types
<span class="line-number">365</span>            field_lines = field_text.split(&#x27;\n&#x27;)
</pre>
<h4>Line 362</h4>
<pre>
<span class="line-number">357</span>            if nested_content:
<span class="line-number">358</span>                # Create a flattened representation
<span class="line-number">359</span>                content_str = &quot;; &quot;.join(nested_content)
<span class="line-number">360</span>                lines.append(f&quot;{base_indent}+ struct {{ {content_str} }} {field.name}&quot;)
<span class="line-number">361</span>            else:
<span class="line-number">362</span><span class="uncovered">                lines.append(f&quot;{base_indent}+ struct {{ }} {field.name}&quot;)</span>
<span class="line-number">363</span>        else:
<span class="line-number">364</span>            # Handle regular multi-line field types
<span class="line-number">365</span>            field_lines = field_text.split(&#x27;\n&#x27;)
<span class="line-number">366</span>            for i, line in enumerate(field_lines):
<span class="line-number">367</span>                if i == 0:
</pre>
<h4>Line 370</h4>
<pre>
<span class="line-number">365</span>            field_lines = field_text.split(&#x27;\n&#x27;)
<span class="line-number">366</span>            for i, line in enumerate(field_lines):
<span class="line-number">367</span>                if i == 0:
<span class="line-number">368</span>                    lines.append(f&quot;{base_indent}+ {line}&quot;)
<span class="line-number">369</span>                else:
<span class="line-number">370</span><span class="uncovered">                    lines.append(f&quot;+ {line}&quot;)</span>
<span class="line-number">371</span>
<span class="line-number">372</span>    def _generate_relationships(
<span class="line-number">373</span>        self,
<span class="line-number">374</span>        lines: List[str],
<span class="line-number">375</span>        include_tree: Dict[str, FileModel],
</pre>
</div>
<div class="file-section">
<div class="file-header">
/workspace/c_to_plantuml/config.py - 89.00% coverage (178/200 lines)
</div>
<h4>Line 54</h4>
<pre>
<span class="line-number"> 49</span>        # Initialize with default values first
<span class="line-number"> 50</span>        object.__init__(self)
<span class="line-number"> 51</span>
<span class="line-number"> 52</span>        # Ensure all dataclass fields are initialized with defaults
<span class="line-number"> 53</span>        if not hasattr(self, &quot;project_name&quot;):
<span class="line-number"> 54</span><span class="uncovered">            self.project_name = &quot;Unknown_Project&quot;</span>
<span class="line-number"> 55</span>        if not hasattr(self, &quot;source_folders&quot;):
<span class="line-number"> 56</span>            self.source_folders = []
<span class="line-number"> 57</span>        if not hasattr(self, &quot;output_dir&quot;):
<span class="line-number"> 58</span>            self.output_dir = &quot;./output&quot;
<span class="line-number"> 59</span>        if not hasattr(self, &quot;model_output_path&quot;):
</pre>
<h4>Line 58</h4>
<pre>
<span class="line-number"> 53</span>        if not hasattr(self, &quot;project_name&quot;):
<span class="line-number"> 54</span>            self.project_name = &quot;Unknown_Project&quot;
<span class="line-number"> 55</span>        if not hasattr(self, &quot;source_folders&quot;):
<span class="line-number"> 56</span>            self.source_folders = []
<span class="line-number"> 57</span>        if not hasattr(self, &quot;output_dir&quot;):
<span class="line-number"> 58</span><span class="uncovered">            self.output_dir = &quot;./output&quot;</span>
<span class="line-number"> 59</span>        if not hasattr(self, &quot;model_output_path&quot;):
<span class="line-number"> 60</span>            self.model_output_path = &quot;model.json&quot;
<span class="line-number"> 61</span>        if not hasattr(self, &quot;recursive_search&quot;):
<span class="line-number"> 62</span>            self.recursive_search = True
<span class="line-number"> 63</span>        if not hasattr(self, &quot;include_depth&quot;):
</pre>
<h4>Line 60</h4>
<pre>
<span class="line-number"> 55</span>        if not hasattr(self, &quot;source_folders&quot;):
<span class="line-number"> 56</span>            self.source_folders = []
<span class="line-number"> 57</span>        if not hasattr(self, &quot;output_dir&quot;):
<span class="line-number"> 58</span>            self.output_dir = &quot;./output&quot;
<span class="line-number"> 59</span>        if not hasattr(self, &quot;model_output_path&quot;):
<span class="line-number"> 60</span><span class="uncovered">            self.model_output_path = &quot;model.json&quot;</span>
<span class="line-number"> 61</span>        if not hasattr(self, &quot;recursive_search&quot;):
<span class="line-number"> 62</span>            self.recursive_search = True
<span class="line-number"> 63</span>        if not hasattr(self, &quot;include_depth&quot;):
<span class="line-number"> 64</span>            self.include_depth = 1
<span class="line-number"> 65</span>        if not hasattr(self, &quot;file_filters&quot;):
</pre>
<h4>Line 62</h4>
<pre>
<span class="line-number"> 57</span>        if not hasattr(self, &quot;output_dir&quot;):
<span class="line-number"> 58</span>            self.output_dir = &quot;./output&quot;
<span class="line-number"> 59</span>        if not hasattr(self, &quot;model_output_path&quot;):
<span class="line-number"> 60</span>            self.model_output_path = &quot;model.json&quot;
<span class="line-number"> 61</span>        if not hasattr(self, &quot;recursive_search&quot;):
<span class="line-number"> 62</span><span class="uncovered">            self.recursive_search = True</span>
<span class="line-number"> 63</span>        if not hasattr(self, &quot;include_depth&quot;):
<span class="line-number"> 64</span>            self.include_depth = 1
<span class="line-number"> 65</span>        if not hasattr(self, &quot;file_filters&quot;):
<span class="line-number"> 66</span>            self.file_filters = {}
<span class="line-number"> 67</span>        if not hasattr(self, &quot;element_filters&quot;):
</pre>
<h4>Line 64</h4>
<pre>
<span class="line-number"> 59</span>        if not hasattr(self, &quot;model_output_path&quot;):
<span class="line-number"> 60</span>            self.model_output_path = &quot;model.json&quot;
<span class="line-number"> 61</span>        if not hasattr(self, &quot;recursive_search&quot;):
<span class="line-number"> 62</span>            self.recursive_search = True
<span class="line-number"> 63</span>        if not hasattr(self, &quot;include_depth&quot;):
<span class="line-number"> 64</span><span class="uncovered">            self.include_depth = 1</span>
<span class="line-number"> 65</span>        if not hasattr(self, &quot;file_filters&quot;):
<span class="line-number"> 66</span>            self.file_filters = {}
<span class="line-number"> 67</span>        if not hasattr(self, &quot;element_filters&quot;):
<span class="line-number"> 68</span>            self.element_filters = {}
<span class="line-number"> 69</span>        if not hasattr(self, &quot;transformations&quot;):
</pre>
<h4>Lines 89-92</h4>
<pre>
<span class="line-number"> 84</span>            for key, value in data.items():
<span class="line-number"> 85</span>                if hasattr(self, key):
<span class="line-number"> 86</span>                    setattr(self, key, value)
<span class="line-number"> 87</span>        elif len(kwargs) == 1 and isinstance(next(iter(kwargs.values())), dict):
<span class="line-number"> 88</span>            # Handle case where a single dict is passed as keyword argument
<span class="line-number"> 89</span><span class="uncovered">            data = next(iter(kwargs.values()))</span>
<span class="line-number"> 90</span><span class="uncovered">            for key, value in data.items():</span>
<span class="line-number"> 91</span><span class="uncovered">                if hasattr(self, key):</span>
<span class="line-number"> 92</span><span class="uncovered">                    setattr(self, key, value)</span>
<span class="line-number"> 93</span>        else:
<span class="line-number"> 94</span>            # Handle normal keyword arguments
<span class="line-number"> 95</span>            for key, value in kwargs.items():
<span class="line-number"> 96</span>                if hasattr(self, key):
<span class="line-number"> 97</span>                    setattr(self, key, value)
</pre>
<h4>Line 104</h4>
<pre>
<span class="line-number"> 99</span>        # Compile patterns after initialization
<span class="line-number">100</span>        self._compile_patterns()
<span class="line-number">101</span>
<span class="line-number">102</span>    def __post_init__(self):
<span class="line-number">103</span>        &quot;&quot;&quot;Compile regex patterns after initialization&quot;&quot;&quot;
<span class="line-number">104</span><span class="uncovered">        self._compile_patterns()</span>
<span class="line-number">105</span>
<span class="line-number">106</span>    def _compile_patterns(self):
<span class="line-number">107</span>        &quot;&quot;&quot;Compile regex patterns for filtering&quot;&quot;&quot;
<span class="line-number">108</span>        # Compile file filter patterns with error handling
<span class="line-number">109</span>        self.file_include_patterns = []
</pre>
<h4>Lines 148-149</h4>
<pre>
<span class="line-number">143</span>            for pattern in filters.get(&quot;exclude&quot;, []):
<span class="line-number">144</span>                try:
<span class="line-number">145</span>                    self.element_exclude_patterns[element_type].append(
<span class="line-number">146</span>                        re.compile(pattern)
<span class="line-number">147</span>                    )
<span class="line-number">148</span><span class="uncovered">                except re.error as e:</span>
<span class="line-number">149</span><span class="uncovered">                    self.logger.warning(</span>
<span class="line-number">150</span>                        &quot;Invalid %s exclude pattern &#x27;%s&#x27;: %s&quot;, element_type, pattern, e
<span class="line-number">151</span>                    )
<span class="line-number">152</span>                    # Skip invalid patterns
<span class="line-number">153</span>
<span class="line-number">154</span>    @classmethod
</pre>
<h4>Line 158</h4>
<pre>
<span class="line-number">153</span>
<span class="line-number">154</span>    @classmethod
<span class="line-number">155</span>    def load(cls, config_file: str) -&gt; &quot;Config&quot;:
<span class="line-number">156</span>        &quot;&quot;&quot;Load configuration from JSON file&quot;&quot;&quot;
<span class="line-number">157</span>        if not Path(config_file).exists():
<span class="line-number">158</span><span class="uncovered">            raise FileNotFoundError(f&quot;Configuration file not found: {config_file}&quot;)</span>
<span class="line-number">159</span>
<span class="line-number">160</span>        try:
<span class="line-number">161</span>            with open(config_file, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:
<span class="line-number">162</span>                data = json.load(f)
<span class="line-number">163</span>
</pre>
<h4>Line 166</h4>
<pre>
<span class="line-number">161</span>            with open(config_file, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:
<span class="line-number">162</span>                data = json.load(f)
<span class="line-number">163</span>
<span class="line-number">164</span>            # Handle backward compatibility: project_roots -&gt; source_folders
<span class="line-number">165</span>            if &quot;project_roots&quot; in data and &quot;source_folders&quot; not in data:
<span class="line-number">166</span><span class="uncovered">                data[&quot;source_folders&quot;] = data.pop(&quot;project_roots&quot;)</span>
<span class="line-number">167</span>
<span class="line-number">168</span>            # Validate required fields
<span class="line-number">169</span>            if &quot;source_folders&quot; not in data:
<span class="line-number">170</span>                raise ValueError(&quot;Configuration must contain &#x27;source_folders&#x27; field&quot;)
<span class="line-number">171</span>
</pre>
<h4>Line 170</h4>
<pre>
<span class="line-number">165</span>            if &quot;project_roots&quot; in data and &quot;source_folders&quot; not in data:
<span class="line-number">166</span>                data[&quot;source_folders&quot;] = data.pop(&quot;project_roots&quot;)
<span class="line-number">167</span>
<span class="line-number">168</span>            # Validate required fields
<span class="line-number">169</span>            if &quot;source_folders&quot; not in data:
<span class="line-number">170</span><span class="uncovered">                raise ValueError(&quot;Configuration must contain &#x27;source_folders&#x27; field&quot;)</span>
<span class="line-number">171</span>
<span class="line-number">172</span>            if not isinstance(data[&quot;source_folders&quot;], list):
<span class="line-number">173</span>                raise ValueError(&quot;&#x27;source_folders&#x27; must be a list&quot;)
<span class="line-number">174</span>
<span class="line-number">175</span>            return cls(**data)
</pre>
<h4>Lines 199-200</h4>
<pre>
<span class="line-number">194</span>        }
<span class="line-number">195</span>
<span class="line-number">196</span>        try:
<span class="line-number">197</span>            with open(config_file, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:
<span class="line-number">198</span>                json.dump(data, f, indent=2, ensure_ascii=False)
<span class="line-number">199</span><span class="uncovered">        except Exception as e:</span>
<span class="line-number">200</span><span class="uncovered">            raise ValueError(</span>
<span class="line-number">201</span>                f&quot;Failed to save configuration to {config_file}: {e}&quot;
<span class="line-number">202</span>            ) from e
<span class="line-number">203</span>
<span class="line-number">204</span>    def has_filters(self) -&gt; bool:
<span class="line-number">205</span>        &quot;&quot;&quot;Check if configuration has any filters defined&quot;&quot;&quot;
</pre>
<h4>Line 260</h4>
<pre>
<span class="line-number">255</span>                filtered_model.enums, self.element_filters[&quot;enums&quot;]
<span class="line-number">256</span>            )
<span class="line-number">257</span>
<span class="line-number">258</span>        # Filter unions
<span class="line-number">259</span>        if &quot;unions&quot; in self.element_filters:
<span class="line-number">260</span><span class="uncovered">            filtered_model.unions = self._filter_dict(</span>
<span class="line-number">261</span>                filtered_model.unions, self.element_filters[&quot;unions&quot;]
<span class="line-number">262</span>            )
<span class="line-number">263</span>
<span class="line-number">264</span>        # Filter functions
<span class="line-number">265</span>        if &quot;functions&quot; in self.element_filters:
</pre>
<h4>Lines 361-362</h4>
<pre>
<span class="line-number">356</span>
<span class="line-number">357</span>            # Check exclude patterns
<span class="line-number">358</span>            should_exclude = False
<span class="line-number">359</span>            for pattern in exclude_patterns:
<span class="line-number">360</span>                if pattern.search(name):
<span class="line-number">361</span><span class="uncovered">                    should_exclude = True</span>
<span class="line-number">362</span><span class="uncovered">                    break</span>
<span class="line-number">363</span>            if should_exclude:
<span class="line-number">364</span>                continue
<span class="line-number">365</span>
<span class="line-number">366</span>            filtered_items.append(item)
<span class="line-number">367</span>
</pre>
<h4>Line 364</h4>
<pre>
<span class="line-number">359</span>            for pattern in exclude_patterns:
<span class="line-number">360</span>                if pattern.search(name):
<span class="line-number">361</span>                    should_exclude = True
<span class="line-number">362</span>                    break
<span class="line-number">363</span>            if should_exclude:
<span class="line-number">364</span><span class="uncovered">                continue</span>
<span class="line-number">365</span>
<span class="line-number">366</span>            filtered_items.append(item)
<span class="line-number">367</span>
<span class="line-number">368</span>        return filtered_items
<span class="line-number">369</span>
</pre>
<h4>Line 386</h4>
<pre>
<span class="line-number">381</span>        }
<span class="line-number">382</span>
<span class="line-number">383</span>    def __eq__(self, other: Any) -&gt; bool:
<span class="line-number">384</span>        &quot;&quot;&quot;Check if two configurations are equal&quot;&quot;&quot;
<span class="line-number">385</span>        if not isinstance(other, Config):
<span class="line-number">386</span><span class="uncovered">            return False</span>
<span class="line-number">387</span>
<span class="line-number">388</span>        return (
<span class="line-number">389</span>            self.project_name == other.project_name
<span class="line-number">390</span>            and self.source_folders == other.source_folders
<span class="line-number">391</span>            and self.output_dir == other.output_dir
</pre>
</div>
<div class="file-section">
<div class="file-header">
/workspace/c_to_plantuml/main.py - 53.61% coverage (52/97 lines)
</div>
<h4>Line 38</h4>
<pre>
<span class="line-number"> 33</span>def load_config_from_path(config_path: str) -&gt; dict:
<span class="line-number"> 34</span>    path = Path(config_path)
<span class="line-number"> 35</span>    if path.is_file():
<span class="line-number"> 36</span>        with open(path, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:
<span class="line-number"> 37</span>            return json.load(f)
<span class="line-number"> 38</span><span class="uncovered">    elif path.is_dir():</span>
<span class="line-number"> 39</span>        # Merge all .json files in the folder
<span class="line-number"> 40</span>        config = {}
<span class="line-number"> 41</span>        for file in path.glob(&quot;*.json&quot;):
<span class="line-number"> 42</span>            with open(file, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:
<span class="line-number"> 43</span>                data = json.load(f)
</pre>
<h4>Lines 40-45</h4>
<pre>
<span class="line-number"> 35</span>    if path.is_file():
<span class="line-number"> 36</span>        with open(path, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:
<span class="line-number"> 37</span>            return json.load(f)
<span class="line-number"> 38</span>    elif path.is_dir():
<span class="line-number"> 39</span>        # Merge all .json files in the folder
<span class="line-number"> 40</span><span class="uncovered">        config = {}</span>
<span class="line-number"> 41</span><span class="uncovered">        for file in path.glob(&quot;*.json&quot;):</span>
<span class="line-number"> 42</span><span class="uncovered">            with open(file, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:</span>
<span class="line-number"> 43</span><span class="uncovered">                data = json.load(f)</span>
<span class="line-number"> 44</span><span class="uncovered">                config.update(data)</span>
<span class="line-number"> 45</span><span class="uncovered">        return config</span>
<span class="line-number"> 46</span>    else:
<span class="line-number"> 47</span>        raise FileNotFoundError(f&quot;Config path not found: {config_path}&quot;)
<span class="line-number"> 48</span>
<span class="line-number"> 49</span>
<span class="line-number"> 50</span>def main() -&gt; int:
</pre>
<h4>Line 47</h4>
<pre>
<span class="line-number"> 42</span>            with open(file, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:
<span class="line-number"> 43</span>                data = json.load(f)
<span class="line-number"> 44</span>                config.update(data)
<span class="line-number"> 45</span>        return config
<span class="line-number"> 46</span>    else:
<span class="line-number"> 47</span><span class="uncovered">        raise FileNotFoundError(f&quot;Config path not found: {config_path}&quot;)</span>
<span class="line-number"> 48</span>
<span class="line-number"> 49</span>
<span class="line-number"> 50</span>def main() -&gt; int:
<span class="line-number"> 51</span>    parser = argparse.ArgumentParser(
<span class="line-number"> 52</span>        description=&quot;C to PlantUML Converter (Simplified CLI)&quot;,
</pre>
<h4>Line 85</h4>
<pre>
<span class="line-number"> 80</span>    setup_logging(args.verbose)
<span class="line-number"> 81</span>
<span class="line-number"> 82</span>    # Determine config path
<span class="line-number"> 83</span>    config_path = args.config
<span class="line-number"> 84</span>    if config_path is None:
<span class="line-number"> 85</span><span class="uncovered">        config_path = os.getcwd()</span>
<span class="line-number"> 86</span>
<span class="line-number"> 87</span>    logging.info(&quot;Using config: %s&quot;, config_path)
<span class="line-number"> 88</span>
<span class="line-number"> 89</span>    # Load config
<span class="line-number"> 90</span>    try:
</pre>
<h4>Lines 93-95</h4>
<pre>
<span class="line-number"> 88</span>
<span class="line-number"> 89</span>    # Load config
<span class="line-number"> 90</span>    try:
<span class="line-number"> 91</span>        config_data = load_config_from_path(config_path)
<span class="line-number"> 92</span>        config = Config(**config_data)
<span class="line-number"> 93</span><span class="uncovered">    except Exception as e:</span>
<span class="line-number"> 94</span><span class="uncovered">        logging.error(&quot;Failed to load configuration: %s&quot;, e)</span>
<span class="line-number"> 95</span><span class="uncovered">        return 1</span>
<span class="line-number"> 96</span>
<span class="line-number"> 97</span>    # Determine output folder from config, default to ./output
<span class="line-number"> 98</span>    output_folder = getattr(config, &quot;output_dir&quot;, None) or os.path.join(
<span class="line-number"> 99</span>        os.getcwd(), &quot;output&quot;
<span class="line-number">100</span>    )
</pre>
<h4>Lines 110-111</h4>
<pre>
<span class="line-number">105</span>    model_file = os.path.join(output_folder, &quot;model.json&quot;)
<span class="line-number">106</span>    transformed_model_file = os.path.join(output_folder, &quot;model_transformed.json&quot;)
<span class="line-number">107</span>
<span class="line-number">108</span>    # Parse command
<span class="line-number">109</span>    if args.command == &quot;parse&quot;:
<span class="line-number">110</span><span class="uncovered">        try:</span>
<span class="line-number">111</span><span class="uncovered">            parser_obj = Parser()</span>
<span class="line-number">112</span>            # Use the refactored parse function that handles both single and multiple source folders
<span class="line-number">113</span>            parser_obj.parse(
<span class="line-number">114</span>                project_root=config.source_folders,
<span class="line-number">115</span>                output_file=model_file,
<span class="line-number">116</span>                recursive_search=getattr(config, &quot;recursive_search&quot;, True),
</pre>
<h4>Line 113</h4>
<pre>
<span class="line-number">108</span>    # Parse command
<span class="line-number">109</span>    if args.command == &quot;parse&quot;:
<span class="line-number">110</span>        try:
<span class="line-number">111</span>            parser_obj = Parser()
<span class="line-number">112</span>            # Use the refactored parse function that handles both single and multiple source folders
<span class="line-number">113</span><span class="uncovered">            parser_obj.parse(</span>
<span class="line-number">114</span>                project_root=config.source_folders,
<span class="line-number">115</span>                output_file=model_file,
<span class="line-number">116</span>                recursive_search=getattr(config, &quot;recursive_search&quot;, True),
<span class="line-number">117</span>                config=config,
<span class="line-number">118</span>            )
</pre>
<h4>Lines 119-123</h4>
<pre>
<span class="line-number">114</span>                project_root=config.source_folders,
<span class="line-number">115</span>                output_file=model_file,
<span class="line-number">116</span>                recursive_search=getattr(config, &quot;recursive_search&quot;, True),
<span class="line-number">117</span>                config=config,
<span class="line-number">118</span>            )
<span class="line-number">119</span><span class="uncovered">            logging.info(&quot;Model saved to: %s&quot;, model_file)</span>
<span class="line-number">120</span><span class="uncovered">            return 0</span>
<span class="line-number">121</span><span class="uncovered">        except (OSError, ValueError, RuntimeError) as e:</span>
<span class="line-number">122</span><span class="uncovered">            logging.error(&quot;Error during parsing: %s&quot;, e)</span>
<span class="line-number">123</span><span class="uncovered">            return 1</span>
<span class="line-number">124</span>
<span class="line-number">125</span>    # Transform command
<span class="line-number">126</span>    if args.command == &quot;transform&quot;:
<span class="line-number">127</span>        try:
<span class="line-number">128</span>            transformer = Transformer()
</pre>
<h4>Lines 127-129</h4>
<pre>
<span class="line-number">122</span>            logging.error(&quot;Error during parsing: %s&quot;, e)
<span class="line-number">123</span>            return 1
<span class="line-number">124</span>
<span class="line-number">125</span>    # Transform command
<span class="line-number">126</span>    if args.command == &quot;transform&quot;:
<span class="line-number">127</span><span class="uncovered">        try:</span>
<span class="line-number">128</span><span class="uncovered">            transformer = Transformer()</span>
<span class="line-number">129</span><span class="uncovered">            transformer.transform(</span>
<span class="line-number">130</span>                model_file=model_file,
<span class="line-number">131</span>                config_file=(
<span class="line-number">132</span>                    config_path
<span class="line-number">133</span>                    if Path(config_path).is_file()
<span class="line-number">134</span>                    else str(list(Path(config_path).glob(&quot;*.json&quot;))[0])
</pre>
<h4>Lines 138-142</h4>
<pre>
<span class="line-number">133</span>                    if Path(config_path).is_file()
<span class="line-number">134</span>                    else str(list(Path(config_path).glob(&quot;*.json&quot;))[0])
<span class="line-number">135</span>                ),
<span class="line-number">136</span>                output_file=transformed_model_file,
<span class="line-number">137</span>            )
<span class="line-number">138</span><span class="uncovered">            logging.info(&quot;Transformed model saved to: %s&quot;, transformed_model_file)</span>
<span class="line-number">139</span><span class="uncovered">            return 0</span>
<span class="line-number">140</span><span class="uncovered">        except (OSError, ValueError, RuntimeError) as e:</span>
<span class="line-number">141</span><span class="uncovered">            logging.error(&quot;Error during transformation: %s&quot;, e)</span>
<span class="line-number">142</span><span class="uncovered">            return 1</span>
<span class="line-number">143</span>
<span class="line-number">144</span>    # Generate command
<span class="line-number">145</span>    if args.command == &quot;generate&quot;:
<span class="line-number">146</span>        try:
<span class="line-number">147</span>            generator = Generator()
</pre>
<h4>Lines 146-147</h4>
<pre>
<span class="line-number">141</span>            logging.error(&quot;Error during transformation: %s&quot;, e)
<span class="line-number">142</span>            return 1
<span class="line-number">143</span>
<span class="line-number">144</span>    # Generate command
<span class="line-number">145</span>    if args.command == &quot;generate&quot;:
<span class="line-number">146</span><span class="uncovered">        try:</span>
<span class="line-number">147</span><span class="uncovered">            generator = Generator()</span>
<span class="line-number">148</span>            # Prefer transformed model, else fallback to model.json
<span class="line-number">149</span>            if os.path.exists(transformed_model_file):
<span class="line-number">150</span>                model_to_use = transformed_model_file
<span class="line-number">151</span>            elif os.path.exists(model_file):
<span class="line-number">152</span>                model_to_use = model_file
</pre>
<h4>Lines 149-152</h4>
<pre>
<span class="line-number">144</span>    # Generate command
<span class="line-number">145</span>    if args.command == &quot;generate&quot;:
<span class="line-number">146</span>        try:
<span class="line-number">147</span>            generator = Generator()
<span class="line-number">148</span>            # Prefer transformed model, else fallback to model.json
<span class="line-number">149</span><span class="uncovered">            if os.path.exists(transformed_model_file):</span>
<span class="line-number">150</span><span class="uncovered">                model_to_use = transformed_model_file</span>
<span class="line-number">151</span><span class="uncovered">            elif os.path.exists(model_file):</span>
<span class="line-number">152</span><span class="uncovered">                model_to_use = model_file</span>
<span class="line-number">153</span>            else:
<span class="line-number">154</span>                logging.error(&quot;No model file found for generation.&quot;)
<span class="line-number">155</span>                return 1
<span class="line-number">156</span>            generator.generate(
<span class="line-number">157</span>                model_file=model_to_use,
</pre>
<h4>Lines 154-156</h4>
<pre>
<span class="line-number">149</span>            if os.path.exists(transformed_model_file):
<span class="line-number">150</span>                model_to_use = transformed_model_file
<span class="line-number">151</span>            elif os.path.exists(model_file):
<span class="line-number">152</span>                model_to_use = model_file
<span class="line-number">153</span>            else:
<span class="line-number">154</span><span class="uncovered">                logging.error(&quot;No model file found for generation.&quot;)</span>
<span class="line-number">155</span><span class="uncovered">                return 1</span>
<span class="line-number">156</span><span class="uncovered">            generator.generate(</span>
<span class="line-number">157</span>                model_file=model_to_use,
<span class="line-number">158</span>                output_dir=output_folder,
<span class="line-number">159</span>                include_depth=getattr(config, &quot;include_depth&quot;, 1),
<span class="line-number">160</span>            )
<span class="line-number">161</span>            logging.info(&quot;PlantUML generation complete! Output in: %s&quot;, output_folder)
</pre>
<h4>Lines 161-165</h4>
<pre>
<span class="line-number">156</span>            generator.generate(
<span class="line-number">157</span>                model_file=model_to_use,
<span class="line-number">158</span>                output_dir=output_folder,
<span class="line-number">159</span>                include_depth=getattr(config, &quot;include_depth&quot;, 1),
<span class="line-number">160</span>            )
<span class="line-number">161</span><span class="uncovered">            logging.info(&quot;PlantUML generation complete! Output in: %s&quot;, output_folder)</span>
<span class="line-number">162</span><span class="uncovered">            return 0</span>
<span class="line-number">163</span><span class="uncovered">        except (OSError, ValueError, RuntimeError) as e:</span>
<span class="line-number">164</span><span class="uncovered">            logging.error(&quot;Error generating PlantUML: %s&quot;, e)</span>
<span class="line-number">165</span><span class="uncovered">            return 1</span>
<span class="line-number">166</span>
<span class="line-number">167</span>    # Default: full workflow
<span class="line-number">168</span>    try:
<span class="line-number">169</span>        # Step 1: Parse
<span class="line-number">170</span>        parser_obj = Parser()
</pre>
<h4>Lines 201-203</h4>
<pre>
<span class="line-number">196</span>            include_depth=getattr(config, &quot;include_depth&quot;, 1),
<span class="line-number">197</span>        )
<span class="line-number">198</span>        logging.info(&quot;PlantUML generation complete! Output in: %s&quot;, output_folder)
<span class="line-number">199</span>        logging.info(&quot;Complete workflow finished successfully!&quot;)
<span class="line-number">200</span>        return 0
<span class="line-number">201</span><span class="uncovered">    except (OSError, ValueError, RuntimeError) as e:</span>
<span class="line-number">202</span><span class="uncovered">        logging.error(&quot;Error in workflow: %s&quot;, e)</span>
<span class="line-number">203</span><span class="uncovered">        return 1</span>
<span class="line-number">204</span>
<span class="line-number">205</span>
<span class="line-number">206</span>if __name__ == &quot;__main__&quot;:
<span class="line-number">207</span>    sys.exit(main())
</pre>
</div>
<div class="file-section">
<div class="file-header">
/workspace/c_to_plantuml/preprocessor.py - 65.76% coverage (194/295 lines)
</div>
<h4>Lines 54-56</h4>
<pre>
<span class="line-number"> 49</span>        self.blocks: List[PreprocessorBlock] = []
<span class="line-number"> 50</span>        self.current_block_stack: List[PreprocessorBlock] = []
<span class="line-number"> 51</span>
<span class="line-number"> 52</span>    def add_define(self, name: str, value: str = &quot;&quot;):
<span class="line-number"> 53</span>        &quot;&quot;&quot;Add a defined macro.&quot;&quot;&quot;
<span class="line-number"> 54</span><span class="uncovered">        self.defined_macros.add(name)</span>
<span class="line-number"> 55</span><span class="uncovered">        if value:</span>
<span class="line-number"> 56</span><span class="uncovered">            self.macro_values[name] = value</span>
<span class="line-number"> 57</span>
<span class="line-number"> 58</span>    def add_undef(self, name: str):
<span class="line-number"> 59</span>        &quot;&quot;&quot;Remove a defined macro.&quot;&quot;&quot;
<span class="line-number"> 60</span>        self.defined_macros.discard(name)
<span class="line-number"> 61</span>        self.macro_values.pop(name, None)
</pre>
<h4>Lines 60-61</h4>
<pre>
<span class="line-number"> 55</span>        if value:
<span class="line-number"> 56</span>            self.macro_values[name] = value
<span class="line-number"> 57</span>
<span class="line-number"> 58</span>    def add_undef(self, name: str):
<span class="line-number"> 59</span>        &quot;&quot;&quot;Remove a defined macro.&quot;&quot;&quot;
<span class="line-number"> 60</span><span class="uncovered">        self.defined_macros.discard(name)</span>
<span class="line-number"> 61</span><span class="uncovered">        self.macro_values.pop(name, None)</span>
<span class="line-number"> 62</span>
<span class="line-number"> 63</span>    def is_defined(self, name: str) -&gt; bool:
<span class="line-number"> 64</span>        &quot;&quot;&quot;Check if a macro is defined.&quot;&quot;&quot;
<span class="line-number"> 65</span>        return name in self.defined_macros
<span class="line-number"> 66</span>
</pre>
<h4>Line 69</h4>
<pre>
<span class="line-number"> 64</span>        &quot;&quot;&quot;Check if a macro is defined.&quot;&quot;&quot;
<span class="line-number"> 65</span>        return name in self.defined_macros
<span class="line-number"> 66</span>
<span class="line-number"> 67</span>    def get_macro_value(self, name: str) -&gt; str:
<span class="line-number"> 68</span>        &quot;&quot;&quot;Get the value of a defined macro.&quot;&quot;&quot;
<span class="line-number"> 69</span><span class="uncovered">        return self.macro_values.get(name, &quot;&quot;)</span>
<span class="line-number"> 70</span>
<span class="line-number"> 71</span>    def evaluate_condition(self, condition: str) -&gt; bool:
<span class="line-number"> 72</span>        &quot;&quot;&quot;Evaluate a preprocessor condition.&quot;&quot;&quot;
<span class="line-number"> 73</span>        if not condition.strip():
<span class="line-number"> 74</span>            return True
</pre>
<h4>Lines 103-104</h4>
<pre>
<span class="line-number"> 98</span>    def _expand_macros(self, condition: str) -&gt; str:
<span class="line-number"> 99</span>        &quot;&quot;&quot;Expand macros in the condition.&quot;&quot;&quot;
<span class="line-number">100</span>        # Simple macro expansion for common cases
<span class="line-number">101</span>        for macro_name, macro_value in self.macro_values.items():
<span class="line-number">102</span>            # Replace macro name with its value
<span class="line-number">103</span><span class="uncovered">            pattern = r&quot;\b&quot; + re.escape(macro_name) + r&quot;\b&quot;</span>
<span class="line-number">104</span><span class="uncovered">            condition = re.sub(pattern, macro_value, condition)</span>
<span class="line-number">105</span>        return condition
<span class="line-number">106</span>
<span class="line-number">107</span>    def _evaluate_simple_expression(self, condition: str) -&gt; bool:
<span class="line-number">108</span>        &quot;&quot;&quot;Evaluate simple expressions like comparisons and logical operators.&quot;&quot;&quot;
<span class="line-number">109</span>        try:
</pre>
<h4>Line 115</h4>
<pre>
<span class="line-number">110</span>            # Handle common comparison operators
<span class="line-number">111</span>            condition = condition.strip()
<span class="line-number">112</span>
<span class="line-number">113</span>            # Handle simple boolean values
<span class="line-number">114</span>            if condition.lower() in [&quot;1&quot;, &quot;true&quot;, &quot;yes&quot;]:
<span class="line-number">115</span><span class="uncovered">                return True</span>
<span class="line-number">116</span>            if condition.lower() in [&quot;0&quot;, &quot;false&quot;, &quot;no&quot;]:
<span class="line-number">117</span>                return False
<span class="line-number">118</span>
<span class="line-number">119</span>            # Handle simple comparisons
<span class="line-number">120</span>            if &quot;==&quot; in condition:
</pre>
<h4>Line 127</h4>
<pre>
<span class="line-number">122</span>                left_val = left.strip()
<span class="line-number">123</span>                right_val = right.strip()
<span class="line-number">124</span>
<span class="line-number">125</span>                # If both sides are known macros, compare their values
<span class="line-number">126</span>                if left_val in self.defined_macros and right_val in self.defined_macros:
<span class="line-number">127</span><span class="uncovered">                    return self.get_macro_value(left_val) == self.get_macro_value(</span>
<span class="line-number">128</span>                        right_val
<span class="line-number">129</span>                    )
<span class="line-number">130</span>                # If one side is a known macro, compare with the other side
<span class="line-number">131</span>                elif left_val in self.defined_macros:
<span class="line-number">132</span>                    return self.get_macro_value(left_val) == right_val
</pre>
<h4>Line 132</h4>
<pre>
<span class="line-number">127</span>                    return self.get_macro_value(left_val) == self.get_macro_value(
<span class="line-number">128</span>                        right_val
<span class="line-number">129</span>                    )
<span class="line-number">130</span>                # If one side is a known macro, compare with the other side
<span class="line-number">131</span>                elif left_val in self.defined_macros:
<span class="line-number">132</span><span class="uncovered">                    return self.get_macro_value(left_val) == right_val</span>
<span class="line-number">133</span>                elif right_val in self.defined_macros:
<span class="line-number">134</span>                    return left_val == self.get_macro_value(right_val)
<span class="line-number">135</span>                # If neither side is a known macro, both are undefined, so they&#x27;re equal
<span class="line-number">136</span>                else:
<span class="line-number">137</span>                    return True  # Both undefined macros are considered equal
</pre>
<h4>Line 134</h4>
<pre>
<span class="line-number">129</span>                    )
<span class="line-number">130</span>                # If one side is a known macro, compare with the other side
<span class="line-number">131</span>                elif left_val in self.defined_macros:
<span class="line-number">132</span>                    return self.get_macro_value(left_val) == right_val
<span class="line-number">133</span>                elif right_val in self.defined_macros:
<span class="line-number">134</span><span class="uncovered">                    return left_val == self.get_macro_value(right_val)</span>
<span class="line-number">135</span>                # If neither side is a known macro, both are undefined, so they&#x27;re equal
<span class="line-number">136</span>                else:
<span class="line-number">137</span>                    return True  # Both undefined macros are considered equal
<span class="line-number">138</span>
<span class="line-number">139</span>            if &quot;!=&quot; in condition:
</pre>
<h4>Lines 140-142</h4>
<pre>
<span class="line-number">135</span>                # If neither side is a known macro, both are undefined, so they&#x27;re equal
<span class="line-number">136</span>                else:
<span class="line-number">137</span>                    return True  # Both undefined macros are considered equal
<span class="line-number">138</span>
<span class="line-number">139</span>            if &quot;!=&quot; in condition:
<span class="line-number">140</span><span class="uncovered">                left, right = condition.split(&quot;!=&quot;, 1)</span>
<span class="line-number">141</span><span class="uncovered">                left_val = left.strip()</span>
<span class="line-number">142</span><span class="uncovered">                right_val = right.strip()</span>
<span class="line-number">143</span>
<span class="line-number">144</span>                # If both sides are known macros, compare their values
<span class="line-number">145</span>                if left_val in self.defined_macros and right_val in self.defined_macros:
<span class="line-number">146</span>                    return self.get_macro_value(left_val) != self.get_macro_value(
<span class="line-number">147</span>                        right_val
</pre>
<h4>Lines 145-146</h4>
<pre>
<span class="line-number">140</span>                left, right = condition.split(&quot;!=&quot;, 1)
<span class="line-number">141</span>                left_val = left.strip()
<span class="line-number">142</span>                right_val = right.strip()
<span class="line-number">143</span>
<span class="line-number">144</span>                # If both sides are known macros, compare their values
<span class="line-number">145</span><span class="uncovered">                if left_val in self.defined_macros and right_val in self.defined_macros:</span>
<span class="line-number">146</span><span class="uncovered">                    return self.get_macro_value(left_val) != self.get_macro_value(</span>
<span class="line-number">147</span>                        right_val
<span class="line-number">148</span>                    )
<span class="line-number">149</span>                # If one side is a known macro, compare with the other side
<span class="line-number">150</span>                elif left_val in self.defined_macros:
<span class="line-number">151</span>                    return self.get_macro_value(left_val) != right_val
</pre>
<h4>Lines 150-153</h4>
<pre>
<span class="line-number">145</span>                if left_val in self.defined_macros and right_val in self.defined_macros:
<span class="line-number">146</span>                    return self.get_macro_value(left_val) != self.get_macro_value(
<span class="line-number">147</span>                        right_val
<span class="line-number">148</span>                    )
<span class="line-number">149</span>                # If one side is a known macro, compare with the other side
<span class="line-number">150</span><span class="uncovered">                elif left_val in self.defined_macros:</span>
<span class="line-number">151</span><span class="uncovered">                    return self.get_macro_value(left_val) != right_val</span>
<span class="line-number">152</span><span class="uncovered">                elif right_val in self.defined_macros:</span>
<span class="line-number">153</span><span class="uncovered">                    return left_val != self.get_macro_value(right_val)</span>
<span class="line-number">154</span>                # If neither side is a known macro, do string comparison
<span class="line-number">155</span>                else:
<span class="line-number">156</span>                    return left_val != right_val
<span class="line-number">157</span>
<span class="line-number">158</span>            if &quot;&gt;&quot; in condition:
</pre>
<h4>Line 156</h4>
<pre>
<span class="line-number">151</span>                    return self.get_macro_value(left_val) != right_val
<span class="line-number">152</span>                elif right_val in self.defined_macros:
<span class="line-number">153</span>                    return left_val != self.get_macro_value(right_val)
<span class="line-number">154</span>                # If neither side is a known macro, do string comparison
<span class="line-number">155</span>                else:
<span class="line-number">156</span><span class="uncovered">                    return left_val != right_val</span>
<span class="line-number">157</span>
<span class="line-number">158</span>            if &quot;&gt;&quot; in condition:
<span class="line-number">159</span>                left, right = condition.split(&quot;&gt;&quot;, 1)
<span class="line-number">160</span>                try:
<span class="line-number">161</span>                    left_val = self._evaluate_operand(left.strip())
</pre>
<h4>Lines 166-189</h4>
<pre>
<span class="line-number">161</span>                    left_val = self._evaluate_operand(left.strip())
<span class="line-number">162</span>                    right_val = self._evaluate_operand(right.strip())
<span class="line-number">163</span>                    return float(left_val) &gt; float(right_val)
<span class="line-number">164</span>                except ValueError:
<span class="line-number">165</span>                    return False
<span class="line-number">166</span><span class="uncovered">            if &quot;&lt;&quot; in condition:</span>
<span class="line-number">167</span><span class="uncovered">                left, right = condition.split(&quot;&lt;&quot;, 1)</span>
<span class="line-number">168</span><span class="uncovered">                try:</span>
<span class="line-number">169</span><span class="uncovered">                    left_val = self._evaluate_operand(left.strip())</span>
<span class="line-number">170</span><span class="uncovered">                    right_val = self._evaluate_operand(right.strip())</span>
<span class="line-number">171</span><span class="uncovered">                    return float(left_val) &lt; float(right_val)</span>
<span class="line-number">172</span><span class="uncovered">                except ValueError:</span>
<span class="line-number">173</span><span class="uncovered">                    return False</span>
<span class="line-number">174</span><span class="uncovered">            if &quot;&gt;=&quot; in condition:</span>
<span class="line-number">175</span><span class="uncovered">                left, right = condition.split(&quot;&gt;=&quot;, 1)</span>
<span class="line-number">176</span><span class="uncovered">                try:</span>
<span class="line-number">177</span><span class="uncovered">                    left_val = self._evaluate_operand(left.strip())</span>
<span class="line-number">178</span><span class="uncovered">                    right_val = self._evaluate_operand(right.strip())</span>
<span class="line-number">179</span><span class="uncovered">                    return float(left_val) &gt;= float(right_val)</span>
<span class="line-number">180</span><span class="uncovered">                except ValueError:</span>
<span class="line-number">181</span><span class="uncovered">                    return False</span>
<span class="line-number">182</span><span class="uncovered">            if &quot;&lt;=&quot; in condition:</span>
<span class="line-number">183</span><span class="uncovered">                left, right = condition.split(&quot;&lt;=&quot;, 1)</span>
<span class="line-number">184</span><span class="uncovered">                try:</span>
<span class="line-number">185</span><span class="uncovered">                    left_val = self._evaluate_operand(left.strip())</span>
<span class="line-number">186</span><span class="uncovered">                    right_val = self._evaluate_operand(right.strip())</span>
<span class="line-number">187</span><span class="uncovered">                    return float(left_val) &lt;= float(right_val)</span>
<span class="line-number">188</span><span class="uncovered">                except ValueError:</span>
<span class="line-number">189</span><span class="uncovered">                    return False</span>
<span class="line-number">190</span>
<span class="line-number">191</span>            # Handle logical operators
<span class="line-number">192</span>            if &quot;&amp;&amp;&quot; in condition:
<span class="line-number">193</span>                parts = condition.split(&quot;&amp;&amp;&quot;)
<span class="line-number">194</span>                return all(
</pre>
<h4>Lines 192-194</h4>
<pre>
<span class="line-number">187</span>                    return float(left_val) &lt;= float(right_val)
<span class="line-number">188</span>                except ValueError:
<span class="line-number">189</span>                    return False
<span class="line-number">190</span>
<span class="line-number">191</span>            # Handle logical operators
<span class="line-number">192</span><span class="uncovered">            if &quot;&amp;&amp;&quot; in condition:</span>
<span class="line-number">193</span><span class="uncovered">                parts = condition.split(&quot;&amp;&amp;&quot;)</span>
<span class="line-number">194</span><span class="uncovered">                return all(</span>
<span class="line-number">195</span>                    self._evaluate_simple_expression(part.strip()) for part in parts
<span class="line-number">196</span>                )
<span class="line-number">197</span>            if &quot;||&quot; in condition:
<span class="line-number">198</span>                parts = condition.split(&quot;||&quot;)
<span class="line-number">199</span>                return any(
</pre>
<h4>Lines 197-199</h4>
<pre>
<span class="line-number">192</span>            if &quot;&amp;&amp;&quot; in condition:
<span class="line-number">193</span>                parts = condition.split(&quot;&amp;&amp;&quot;)
<span class="line-number">194</span>                return all(
<span class="line-number">195</span>                    self._evaluate_simple_expression(part.strip()) for part in parts
<span class="line-number">196</span>                )
<span class="line-number">197</span><span class="uncovered">            if &quot;||&quot; in condition:</span>
<span class="line-number">198</span><span class="uncovered">                parts = condition.split(&quot;||&quot;)</span>
<span class="line-number">199</span><span class="uncovered">                return any(</span>
<span class="line-number">200</span>                    self._evaluate_simple_expression(part.strip()) for part in parts
<span class="line-number">201</span>                )
<span class="line-number">202</span>            if &quot;!&quot; in condition:
<span class="line-number">203</span>                # Simple negation
<span class="line-number">204</span>                negated = condition.replace(&quot;!&quot;, &quot;&quot;).strip()
</pre>
<h4>Line 202</h4>
<pre>
<span class="line-number">197</span>            if &quot;||&quot; in condition:
<span class="line-number">198</span>                parts = condition.split(&quot;||&quot;)
<span class="line-number">199</span>                return any(
<span class="line-number">200</span>                    self._evaluate_simple_expression(part.strip()) for part in parts
<span class="line-number">201</span>                )
<span class="line-number">202</span><span class="uncovered">            if &quot;!&quot; in condition:</span>
<span class="line-number">203</span>                # Simple negation
<span class="line-number">204</span>                negated = condition.replace(&quot;!&quot;, &quot;&quot;).strip()
<span class="line-number">205</span>                return not self._evaluate_simple_expression(negated)
<span class="line-number">206</span>
<span class="line-number">207</span>            # If it&#x27;s just a macro name, check if it&#x27;s defined
</pre>
<h4>Lines 204-205</h4>
<pre>
<span class="line-number">199</span>                return any(
<span class="line-number">200</span>                    self._evaluate_simple_expression(part.strip()) for part in parts
<span class="line-number">201</span>                )
<span class="line-number">202</span>            if &quot;!&quot; in condition:
<span class="line-number">203</span>                # Simple negation
<span class="line-number">204</span><span class="uncovered">                negated = condition.replace(&quot;!&quot;, &quot;&quot;).strip()</span>
<span class="line-number">205</span><span class="uncovered">                return not self._evaluate_simple_expression(negated)</span>
<span class="line-number">206</span>
<span class="line-number">207</span>            # If it&#x27;s just a macro name, check if it&#x27;s defined
<span class="line-number">208</span>            if condition in self.defined_macros:
<span class="line-number">209</span>                return True
<span class="line-number">210</span>
</pre>
<h4>Lines 208-209</h4>
<pre>
<span class="line-number">203</span>                # Simple negation
<span class="line-number">204</span>                negated = condition.replace(&quot;!&quot;, &quot;&quot;).strip()
<span class="line-number">205</span>                return not self._evaluate_simple_expression(negated)
<span class="line-number">206</span>
<span class="line-number">207</span>            # If it&#x27;s just a macro name, check if it&#x27;s defined
<span class="line-number">208</span><span class="uncovered">            if condition in self.defined_macros:</span>
<span class="line-number">209</span><span class="uncovered">                return True</span>
<span class="line-number">210</span>
<span class="line-number">211</span>            # Try to evaluate as a number
<span class="line-number">212</span>            try:
<span class="line-number">213</span>                return bool(int(condition))
<span class="line-number">214</span>            except ValueError:
</pre>
<h4>Lines 212-215</h4>
<pre>
<span class="line-number">207</span>            # If it&#x27;s just a macro name, check if it&#x27;s defined
<span class="line-number">208</span>            if condition in self.defined_macros:
<span class="line-number">209</span>                return True
<span class="line-number">210</span>
<span class="line-number">211</span>            # Try to evaluate as a number
<span class="line-number">212</span><span class="uncovered">            try:</span>
<span class="line-number">213</span><span class="uncovered">                return bool(int(condition))</span>
<span class="line-number">214</span><span class="uncovered">            except ValueError:</span>
<span class="line-number">215</span><span class="uncovered">                pass</span>
<span class="line-number">216</span>
<span class="line-number">217</span>            # Default to True for unknown conditions (backward compatibility)
<span class="line-number">218</span>            # This ensures existing tests continue to work
<span class="line-number">219</span>            return True
<span class="line-number">220</span>
</pre>
<h4>Line 219</h4>
<pre>
<span class="line-number">214</span>            except ValueError:
<span class="line-number">215</span>                pass
<span class="line-number">216</span>
<span class="line-number">217</span>            # Default to True for unknown conditions (backward compatibility)
<span class="line-number">218</span>            # This ensures existing tests continue to work
<span class="line-number">219</span><span class="uncovered">            return True</span>
<span class="line-number">220</span>
<span class="line-number">221</span>        except ValueError as e:
<span class="line-number">222</span>            self.logger.warning(
<span class="line-number">223</span>                &quot;Error evaluating preprocessor condition &#x27;%s&#x27;: %s&quot;, condition, e
<span class="line-number">224</span>            )
</pre>
<h4>Lines 221-222</h4>
<pre>
<span class="line-number">216</span>
<span class="line-number">217</span>            # Default to True for unknown conditions (backward compatibility)
<span class="line-number">218</span>            # This ensures existing tests continue to work
<span class="line-number">219</span>            return True
<span class="line-number">220</span>
<span class="line-number">221</span><span class="uncovered">        except ValueError as e:</span>
<span class="line-number">222</span><span class="uncovered">            self.logger.warning(</span>
<span class="line-number">223</span>                &quot;Error evaluating preprocessor condition &#x27;%s&#x27;: %s&quot;, condition, e
<span class="line-number">224</span>            )
<span class="line-number">225</span>            # Default to True for unknown conditions (backward compatibility)
<span class="line-number">226</span>            return True
<span class="line-number">227</span>
</pre>
<h4>Line 226</h4>
<pre>
<span class="line-number">221</span>        except ValueError as e:
<span class="line-number">222</span>            self.logger.warning(
<span class="line-number">223</span>                &quot;Error evaluating preprocessor condition &#x27;%s&#x27;: %s&quot;, condition, e
<span class="line-number">224</span>            )
<span class="line-number">225</span>            # Default to True for unknown conditions (backward compatibility)
<span class="line-number">226</span><span class="uncovered">            return True</span>
<span class="line-number">227</span>
<span class="line-number">228</span>    def _evaluate_operand(self, operand: str) -&gt; str:
<span class="line-number">229</span>        &quot;&quot;&quot;Evaluate an operand, expanding macros if they are defined.&quot;&quot;&quot;
<span class="line-number">230</span>        operand = operand.strip()
<span class="line-number">231</span>
</pre>
<h4>Line 234</h4>
<pre>
<span class="line-number">229</span>        &quot;&quot;&quot;Evaluate an operand, expanding macros if they are defined.&quot;&quot;&quot;
<span class="line-number">230</span>        operand = operand.strip()
<span class="line-number">231</span>
<span class="line-number">232</span>        # If it&#x27;s a defined macro, return its value
<span class="line-number">233</span>        if operand in self.defined_macros:
<span class="line-number">234</span><span class="uncovered">            return self.get_macro_value(operand)</span>
<span class="line-number">235</span>
<span class="line-number">236</span>        # Otherwise, return the operand as-is
<span class="line-number">237</span>        return operand
<span class="line-number">238</span>
<span class="line-number">239</span>    def parse_preprocessor_blocks(self, tokens: List[Token]) -&gt; List[PreprocessorBlock]:
</pre>
<h4>Line 300</h4>
<pre>
<span class="line-number">295</span>                    if stack:
<span class="line-number">296</span>                        # End current block
<span class="line-number">297</span>                        current_block = stack.pop()
<span class="line-number">298</span>                        current_block.end_token = i
<span class="line-number">299</span>
<span class="line-number">300</span><span class="uncovered">                elif directive == PreprocessorDirective.DEFINE:</span>
<span class="line-number">301</span>                    # Handle #define
<span class="line-number">302</span>                    macro_name, macro_value = self._parse_define(token.value)
<span class="line-number">303</span>                    self.add_define(macro_name, macro_value)
<span class="line-number">304</span>
<span class="line-number">305</span>                elif directive == PreprocessorDirective.UNDEF:
</pre>
<h4>Lines 302-303</h4>
<pre>
<span class="line-number">297</span>                        current_block = stack.pop()
<span class="line-number">298</span>                        current_block.end_token = i
<span class="line-number">299</span>
<span class="line-number">300</span>                elif directive == PreprocessorDirective.DEFINE:
<span class="line-number">301</span>                    # Handle #define
<span class="line-number">302</span><span class="uncovered">                    macro_name, macro_value = self._parse_define(token.value)</span>
<span class="line-number">303</span><span class="uncovered">                    self.add_define(macro_name, macro_value)</span>
<span class="line-number">304</span>
<span class="line-number">305</span>                elif directive == PreprocessorDirective.UNDEF:
<span class="line-number">306</span>                    # Handle #undef
<span class="line-number">307</span>                    macro_name = self._parse_undef(token.value)
<span class="line-number">308</span>                    self.add_undef(macro_name)
</pre>
<h4>Line 305</h4>
<pre>
<span class="line-number">300</span>                elif directive == PreprocessorDirective.DEFINE:
<span class="line-number">301</span>                    # Handle #define
<span class="line-number">302</span>                    macro_name, macro_value = self._parse_define(token.value)
<span class="line-number">303</span>                    self.add_define(macro_name, macro_value)
<span class="line-number">304</span>
<span class="line-number">305</span><span class="uncovered">                elif directive == PreprocessorDirective.UNDEF:</span>
<span class="line-number">306</span>                    # Handle #undef
<span class="line-number">307</span>                    macro_name = self._parse_undef(token.value)
<span class="line-number">308</span>                    self.add_undef(macro_name)
<span class="line-number">309</span>
<span class="line-number">310</span>            i += 1
</pre>
<h4>Lines 307-308</h4>
<pre>
<span class="line-number">302</span>                    macro_name, macro_value = self._parse_define(token.value)
<span class="line-number">303</span>                    self.add_define(macro_name, macro_value)
<span class="line-number">304</span>
<span class="line-number">305</span>                elif directive == PreprocessorDirective.UNDEF:
<span class="line-number">306</span>                    # Handle #undef
<span class="line-number">307</span><span class="uncovered">                    macro_name = self._parse_undef(token.value)</span>
<span class="line-number">308</span><span class="uncovered">                    self.add_undef(macro_name)</span>
<span class="line-number">309</span>
<span class="line-number">310</span>            i += 1
<span class="line-number">311</span>
<span class="line-number">312</span>        return blocks
<span class="line-number">313</span>
</pre>
<h4>Lines 329-332</h4>
<pre>
<span class="line-number">324</span>            return PreprocessorDirective.ELIF
<span class="line-number">325</span>        elif value.startswith(&quot;#else&quot;):
<span class="line-number">326</span>            return PreprocessorDirective.ELSE
<span class="line-number">327</span>        elif value.startswith(&quot;#endif&quot;):
<span class="line-number">328</span>            return PreprocessorDirective.ENDIF
<span class="line-number">329</span><span class="uncovered">        elif value.startswith(&quot;#define&quot;):</span>
<span class="line-number">330</span><span class="uncovered">            return PreprocessorDirective.DEFINE</span>
<span class="line-number">331</span><span class="uncovered">        elif value.startswith(&quot;#undef&quot;):</span>
<span class="line-number">332</span><span class="uncovered">            return PreprocessorDirective.UNDEF</span>
<span class="line-number">333</span>        else:
<span class="line-number">334</span>            return PreprocessorDirective.IF  # Default
<span class="line-number">335</span>
<span class="line-number">336</span>    def _extract_condition(self, value: str, directive: PreprocessorDirective) -&gt; str:
<span class="line-number">337</span>        &quot;&quot;&quot;Extract the condition from a preprocessor directive.&quot;&quot;&quot;
</pre>
<h4>Line 334</h4>
<pre>
<span class="line-number">329</span>        elif value.startswith(&quot;#define&quot;):
<span class="line-number">330</span>            return PreprocessorDirective.DEFINE
<span class="line-number">331</span>        elif value.startswith(&quot;#undef&quot;):
<span class="line-number">332</span>            return PreprocessorDirective.UNDEF
<span class="line-number">333</span>        else:
<span class="line-number">334</span><span class="uncovered">            return PreprocessorDirective.IF  # Default</span>
<span class="line-number">335</span>
<span class="line-number">336</span>    def _extract_condition(self, value: str, directive: PreprocessorDirective) -&gt; str:
<span class="line-number">337</span>        &quot;&quot;&quot;Extract the condition from a preprocessor directive.&quot;&quot;&quot;
<span class="line-number">338</span>        value = value.strip()
<span class="line-number">339</span>
</pre>
<h4>Line 353</h4>
<pre>
<span class="line-number">348</span>            return match.group(1).strip() if match else &quot;&quot;
<span class="line-number">349</span>        elif directive == PreprocessorDirective.ELIF:
<span class="line-number">350</span>            match = re.search(r&quot;#elif\s+(.+)&quot;, value)
<span class="line-number">351</span>            return match.group(1).strip() if match else &quot;&quot;
<span class="line-number">352</span>        else:
<span class="line-number">353</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">354</span>
<span class="line-number">355</span>    def _parse_define(self, value: str) -&gt; Tuple[str, str]:
<span class="line-number">356</span>        &quot;&quot;&quot;Parse #define directive.&quot;&quot;&quot;
<span class="line-number">357</span>        value = value.strip()
<span class="line-number">358</span>        match = re.search(r&quot;#define\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(.+)&quot;, value)
</pre>
<h4>Lines 357-363</h4>
<pre>
<span class="line-number">352</span>        else:
<span class="line-number">353</span>            return &quot;&quot;
<span class="line-number">354</span>
<span class="line-number">355</span>    def _parse_define(self, value: str) -&gt; Tuple[str, str]:
<span class="line-number">356</span>        &quot;&quot;&quot;Parse #define directive.&quot;&quot;&quot;
<span class="line-number">357</span><span class="uncovered">        value = value.strip()</span>
<span class="line-number">358</span><span class="uncovered">        match = re.search(r&quot;#define\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(.+)&quot;, value)</span>
<span class="line-number">359</span><span class="uncovered">        if match:</span>
<span class="line-number">360</span><span class="uncovered">            name = match.group(1)</span>
<span class="line-number">361</span><span class="uncovered">            macro_value = match.group(2).strip()</span>
<span class="line-number">362</span><span class="uncovered">            return name, macro_value</span>
<span class="line-number">363</span><span class="uncovered">        return &quot;&quot;, &quot;&quot;</span>
<span class="line-number">364</span>
<span class="line-number">365</span>    def _parse_undef(self, value: str) -&gt; str:
<span class="line-number">366</span>        &quot;&quot;&quot;Parse #undef directive.&quot;&quot;&quot;
<span class="line-number">367</span>        value = value.strip()
<span class="line-number">368</span>        match = re.search(r&quot;#undef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)
</pre>
<h4>Lines 367-369</h4>
<pre>
<span class="line-number">362</span>            return name, macro_value
<span class="line-number">363</span>        return &quot;&quot;, &quot;&quot;
<span class="line-number">364</span>
<span class="line-number">365</span>    def _parse_undef(self, value: str) -&gt; str:
<span class="line-number">366</span>        &quot;&quot;&quot;Parse #undef directive.&quot;&quot;&quot;
<span class="line-number">367</span><span class="uncovered">        value = value.strip()</span>
<span class="line-number">368</span><span class="uncovered">        match = re.search(r&quot;#undef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)</span>
<span class="line-number">369</span><span class="uncovered">        return match.group(1) if match else &quot;&quot;</span>
<span class="line-number">370</span>
<span class="line-number">371</span>    def _should_activate_block(
<span class="line-number">372</span>        self,
<span class="line-number">373</span>        directive: PreprocessorDirective,
<span class="line-number">374</span>        condition: str,
</pre>
<h4>Lines 394-395</h4>
<pre>
<span class="line-number">389</span>            # For #elif, we need to check if no previous branch was taken
<span class="line-number">390</span>            if stack:
<span class="line-number">391</span>                parent = stack[-1]
<span class="line-number">392</span>                # Check if any previous child was active
<span class="line-number">393</span>                for child in parent.children:
<span class="line-number">394</span><span class="uncovered">                    if child.is_active:</span>
<span class="line-number">395</span><span class="uncovered">                        return False</span>
<span class="line-number">396</span>                return self.evaluate_condition(condition)
<span class="line-number">397</span>            return False
<span class="line-number">398</span>        elif directive == PreprocessorDirective.ELSE:
<span class="line-number">399</span>            # For #else, we need to check if no previous branch was taken
<span class="line-number">400</span>            if stack:
</pre>
<h4>Line 397</h4>
<pre>
<span class="line-number">392</span>                # Check if any previous child was active
<span class="line-number">393</span>                for child in parent.children:
<span class="line-number">394</span>                    if child.is_active:
<span class="line-number">395</span>                        return False
<span class="line-number">396</span>                return self.evaluate_condition(condition)
<span class="line-number">397</span><span class="uncovered">            return False</span>
<span class="line-number">398</span>        elif directive == PreprocessorDirective.ELSE:
<span class="line-number">399</span>            # For #else, we need to check if no previous branch was taken
<span class="line-number">400</span>            if stack:
<span class="line-number">401</span>                parent = stack[-1]
<span class="line-number">402</span>                # Check if any previous child was active
</pre>
<h4>Lines 404-405</h4>
<pre>
<span class="line-number">399</span>            # For #else, we need to check if no previous branch was taken
<span class="line-number">400</span>            if stack:
<span class="line-number">401</span>                parent = stack[-1]
<span class="line-number">402</span>                # Check if any previous child was active
<span class="line-number">403</span>                for child in parent.children:
<span class="line-number">404</span><span class="uncovered">                    if child.is_active:</span>
<span class="line-number">405</span><span class="uncovered">                        return False</span>
<span class="line-number">406</span>                return True
<span class="line-number">407</span>            return False
<span class="line-number">408</span>        else:
<span class="line-number">409</span>            return False
<span class="line-number">410</span>
</pre>
<h4>Line 407</h4>
<pre>
<span class="line-number">402</span>                # Check if any previous child was active
<span class="line-number">403</span>                for child in parent.children:
<span class="line-number">404</span>                    if child.is_active:
<span class="line-number">405</span>                        return False
<span class="line-number">406</span>                return True
<span class="line-number">407</span><span class="uncovered">            return False</span>
<span class="line-number">408</span>        else:
<span class="line-number">409</span>            return False
<span class="line-number">410</span>
<span class="line-number">411</span>    def filter_tokens(self, tokens: List[Token]) -&gt; List[Token]:
<span class="line-number">412</span>        &quot;&quot;&quot;Filter tokens based on preprocessor blocks, keeping only active content.&quot;&quot;&quot;
</pre>
<h4>Line 409</h4>
<pre>
<span class="line-number">404</span>                    if child.is_active:
<span class="line-number">405</span>                        return False
<span class="line-number">406</span>                return True
<span class="line-number">407</span>            return False
<span class="line-number">408</span>        else:
<span class="line-number">409</span><span class="uncovered">            return False</span>
<span class="line-number">410</span>
<span class="line-number">411</span>    def filter_tokens(self, tokens: List[Token]) -&gt; List[Token]:
<span class="line-number">412</span>        &quot;&quot;&quot;Filter tokens based on preprocessor blocks, keeping only active content.&quot;&quot;&quot;
<span class="line-number">413</span>        blocks = self.parse_preprocessor_blocks(tokens)
<span class="line-number">414</span>        filtered_tokens = []
</pre>
<h4>Lines 471-472</h4>
<pre>
<span class="line-number">466</span>    def process_file(
<span class="line-number">467</span>        self, tokens: List[Token], defines: Optional[Dict[str, str]] = None
<span class="line-number">468</span>    ) -&gt; List[Token]:
<span class="line-number">469</span>        &quot;&quot;&quot;Process a file&#x27;s tokens through the preprocessor.&quot;&quot;&quot;
<span class="line-number">470</span>        if defines:
<span class="line-number">471</span><span class="uncovered">            for name, value in defines.items():</span>
<span class="line-number">472</span><span class="uncovered">                self.evaluator.add_define(name, value)</span>
<span class="line-number">473</span>
<span class="line-number">474</span>        # Filter tokens based on preprocessor directives
<span class="line-number">475</span>        filtered_tokens = self.evaluator.filter_tokens(tokens)
<span class="line-number">476</span>
<span class="line-number">477</span>        self.logger.debug(
</pre>
<h4>Lines 488-491</h4>
<pre>
<span class="line-number">483</span>        &quot;&quot;&quot;Extract #define directives from tokens and add them to the evaluator.&quot;&quot;&quot;
<span class="line-number">484</span>        for token in tokens:
<span class="line-number">485</span>            if token.type == TokenType.PREPROCESSOR and token.value.startswith(
<span class="line-number">486</span>                &quot;#define&quot;
<span class="line-number">487</span>            ):
<span class="line-number">488</span><span class="uncovered">                name, value = self.evaluator._parse_define(token.value)</span>
<span class="line-number">489</span><span class="uncovered">                if name:</span>
<span class="line-number">490</span><span class="uncovered">                    self.evaluator.add_define(name, value)</span>
<span class="line-number">491</span><span class="uncovered">                    self.logger.debug(&quot;Preprocessor: Added define %s = %s&quot;, name, value)</span>
</pre>
</div>
<div class="file-section">
<div class="file-header">
/workspace/c_to_plantuml/utils.py - 61.19% coverage (41/67 lines)
</div>
<h4>Line 13</h4>
<pre>
<span class="line-number">  8</span>from typing import Dict, Optional
<span class="line-number">  9</span>
<span class="line-number"> 10</span># Try to import chardet, fallback to basic encoding detection if not available
<span class="line-number"> 11</span>try:
<span class="line-number"> 12</span>    import chardet
<span class="line-number"> 13</span><span class="uncovered">    CHARDET_AVAILABLE = True</span>
<span class="line-number"> 14</span>except ImportError:
<span class="line-number"> 15</span>    CHARDET_AVAILABLE = False
<span class="line-number"> 16</span>
<span class="line-number"> 17</span>
<span class="line-number"> 18</span>def detect_file_encoding(file_path: Path) -&gt; str:
</pre>
<h4>Lines 23-28</h4>
<pre>
<span class="line-number"> 18</span>def detect_file_encoding(file_path: Path) -&gt; str:
<span class="line-number"> 19</span>    &quot;&quot;&quot;Detect file encoding with platform-aware fallbacks&quot;&quot;&quot;
<span class="line-number"> 20</span>    try:
<span class="line-number"> 21</span>        if CHARDET_AVAILABLE:
<span class="line-number"> 22</span>            # Try to detect encoding with chardet
<span class="line-number"> 23</span><span class="uncovered">            with open(file_path, &quot;rb&quot;) as f:</span>
<span class="line-number"> 24</span><span class="uncovered">                raw_data = f.read(1024)  # Read first 1KB for detection</span>
<span class="line-number"> 25</span><span class="uncovered">                if raw_data:</span>
<span class="line-number"> 26</span><span class="uncovered">                    result = chardet.detect(raw_data)</span>
<span class="line-number"> 27</span><span class="uncovered">                    if result and result[&quot;confidence&quot;] &gt; 0.7:</span>
<span class="line-number"> 28</span><span class="uncovered">                        return result[&quot;encoding&quot;]</span>
<span class="line-number"> 29</span>
<span class="line-number"> 30</span>        # Fallback encodings in order of preference
<span class="line-number"> 31</span>        fallback_encodings = [&quot;utf-8&quot;, &quot;latin-1&quot;, &quot;cp1252&quot;, &quot;iso-8859-1&quot;]
<span class="line-number"> 32</span>
<span class="line-number"> 33</span>        for encoding in fallback_encodings:
</pre>
<h4>Line 39</h4>
<pre>
<span class="line-number"> 34</span>            try:
<span class="line-number"> 35</span>                with open(file_path, &quot;r&quot;, encoding=encoding) as f:
<span class="line-number"> 36</span>                    f.read(1024)  # Test read
<span class="line-number"> 37</span>                return encoding
<span class="line-number"> 38</span>            except (UnicodeDecodeError, UnicodeError):
<span class="line-number"> 39</span><span class="uncovered">                continue</span>
<span class="line-number"> 40</span>
<span class="line-number"> 41</span>        # Final fallback
<span class="line-number"> 42</span>        return &quot;utf-8&quot;
<span class="line-number"> 43</span>
<span class="line-number"> 44</span>    except Exception as e:
</pre>
<h4>Line 42</h4>
<pre>
<span class="line-number"> 37</span>                return encoding
<span class="line-number"> 38</span>            except (UnicodeDecodeError, UnicodeError):
<span class="line-number"> 39</span>                continue
<span class="line-number"> 40</span>
<span class="line-number"> 41</span>        # Final fallback
<span class="line-number"> 42</span><span class="uncovered">        return &quot;utf-8&quot;</span>
<span class="line-number"> 43</span>
<span class="line-number"> 44</span>    except Exception as e:
<span class="line-number"> 45</span>        logging.warning(f&quot;Failed to detect encoding for {file_path}: {e}&quot;)
<span class="line-number"> 46</span>        return &quot;utf-8&quot;
<span class="line-number"> 47</span>
</pre>
<h4>Line 51</h4>
<pre>
<span class="line-number"> 46</span>        return &quot;utf-8&quot;
<span class="line-number"> 47</span>
<span class="line-number"> 48</span>
<span class="line-number"> 49</span>def get_filename_from_path(file_path: str) -&gt; str:
<span class="line-number"> 50</span>    &quot;&quot;&quot;Extract filename from a file path (handles both absolute and relative paths)&quot;&quot;&quot;
<span class="line-number"> 51</span><span class="uncovered">    return Path(file_path).name</span>
<span class="line-number"> 52</span>
<span class="line-number"> 53</span>
<span class="line-number"> 54</span>def find_file_by_filename(filename: str, file_dict: Dict[str, any]) -&gt; Optional[str]:
<span class="line-number"> 55</span>    &quot;&quot;&quot;
<span class="line-number"> 56</span>    Find a file in a dictionary by matching its filename.
</pre>
<h4>Lines 66-67</h4>
<pre>
<span class="line-number"> 61</span>
<span class="line-number"> 62</span>    Returns:
<span class="line-number"> 63</span>        The matching file path key, or None if not found
<span class="line-number"> 64</span>    &quot;&quot;&quot;
<span class="line-number"> 65</span>    # First try exact match
<span class="line-number"> 66</span><span class="uncovered">    if filename in file_dict:</span>
<span class="line-number"> 67</span><span class="uncovered">        return filename</span>
<span class="line-number"> 68</span>
<span class="line-number"> 69</span>    # Try matching by filename
<span class="line-number"> 70</span>    for file_path in file_dict.keys():
<span class="line-number"> 71</span>        if Path(file_path).name == filename:
<span class="line-number"> 72</span>            return file_path
</pre>
<h4>Lines 70-72</h4>
<pre>
<span class="line-number"> 65</span>    # First try exact match
<span class="line-number"> 66</span>    if filename in file_dict:
<span class="line-number"> 67</span>        return filename
<span class="line-number"> 68</span>
<span class="line-number"> 69</span>    # Try matching by filename
<span class="line-number"> 70</span><span class="uncovered">    for file_path in file_dict.keys():</span>
<span class="line-number"> 71</span><span class="uncovered">        if Path(file_path).name == filename:</span>
<span class="line-number"> 72</span><span class="uncovered">            return file_path</span>
<span class="line-number"> 73</span>
<span class="line-number"> 74</span>    return None
<span class="line-number"> 75</span>
<span class="line-number"> 76</span>
<span class="line-number"> 77</span>def normalize_file_path(file_path: str, project_root: str = None) -&gt; str:
</pre>
<h4>Line 74</h4>
<pre>
<span class="line-number"> 69</span>    # Try matching by filename
<span class="line-number"> 70</span>    for file_path in file_dict.keys():
<span class="line-number"> 71</span>        if Path(file_path).name == filename:
<span class="line-number"> 72</span>            return file_path
<span class="line-number"> 73</span>
<span class="line-number"> 74</span><span class="uncovered">    return None</span>
<span class="line-number"> 75</span>
<span class="line-number"> 76</span>
<span class="line-number"> 77</span>def normalize_file_path(file_path: str, project_root: str = None) -&gt; str:
<span class="line-number"> 78</span>    &quot;&quot;&quot;
<span class="line-number"> 79</span>    Normalize file path for consistent handling.
</pre>
<h4>Line 89</h4>
<pre>
<span class="line-number"> 84</span>        project_root: Optional project root for relative path conversion
<span class="line-number"> 85</span>
<span class="line-number"> 86</span>    Returns:
<span class="line-number"> 87</span>        Normalized file path
<span class="line-number"> 88</span>    &quot;&quot;&quot;
<span class="line-number"> 89</span><span class="uncovered">    path_obj = Path(file_path)</span>
<span class="line-number"> 90</span>
<span class="line-number"> 91</span>    # If we have a project root and the path is absolute, try to make it relative
<span class="line-number"> 92</span>    if project_root and path_obj.is_absolute():
<span class="line-number"> 93</span>        try:
<span class="line-number"> 94</span>            relative_path = path_obj.relative_to(Path(project_root))
</pre>
<h4>Lines 92-96</h4>
<pre>
<span class="line-number"> 87</span>        Normalized file path
<span class="line-number"> 88</span>    &quot;&quot;&quot;
<span class="line-number"> 89</span>    path_obj = Path(file_path)
<span class="line-number"> 90</span>
<span class="line-number"> 91</span>    # If we have a project root and the path is absolute, try to make it relative
<span class="line-number"> 92</span><span class="uncovered">    if project_root and path_obj.is_absolute():</span>
<span class="line-number"> 93</span><span class="uncovered">        try:</span>
<span class="line-number"> 94</span><span class="uncovered">            relative_path = path_obj.relative_to(Path(project_root))</span>
<span class="line-number"> 95</span><span class="uncovered">            return str(relative_path)</span>
<span class="line-number"> 96</span><span class="uncovered">        except ValueError:</span>
<span class="line-number"> 97</span>            # Path is not relative to project root, keep as is
<span class="line-number"> 98</span>            pass
<span class="line-number"> 99</span>
<span class="line-number">100</span>    return str(path_obj)
<span class="line-number">101</span>
</pre>
<h4>Line 98</h4>
<pre>
<span class="line-number"> 93</span>        try:
<span class="line-number"> 94</span>            relative_path = path_obj.relative_to(Path(project_root))
<span class="line-number"> 95</span>            return str(relative_path)
<span class="line-number"> 96</span>        except ValueError:
<span class="line-number"> 97</span>            # Path is not relative to project root, keep as is
<span class="line-number"> 98</span><span class="uncovered">            pass</span>
<span class="line-number"> 99</span>
<span class="line-number">100</span>    return str(path_obj)
<span class="line-number">101</span>
<span class="line-number">102</span>
<span class="line-number">103</span>def create_file_key(file_path: str, project_root: str = None) -&gt; str:
</pre>
<h4>Line 100</h4>
<pre>
<span class="line-number"> 95</span>            return str(relative_path)
<span class="line-number"> 96</span>        except ValueError:
<span class="line-number"> 97</span>            # Path is not relative to project root, keep as is
<span class="line-number"> 98</span>            pass
<span class="line-number"> 99</span>
<span class="line-number">100</span><span class="uncovered">    return str(path_obj)</span>
<span class="line-number">101</span>
<span class="line-number">102</span>
<span class="line-number">103</span>def create_file_key(file_path: str, project_root: str = None) -&gt; str:
<span class="line-number">104</span>    &quot;&quot;&quot;
<span class="line-number">105</span>    Create a consistent file key for tracking.
</pre>
<h4>Line 115</h4>
<pre>
<span class="line-number">110</span>        project_root: Optional project root for normalization
<span class="line-number">111</span>
<span class="line-number">112</span>    Returns:
<span class="line-number">113</span>        A consistent file key (filename)
<span class="line-number">114</span>    &quot;&quot;&quot;
<span class="line-number">115</span><span class="uncovered">    return get_filename_from_path(file_path)</span>
<span class="line-number">116</span>
<span class="line-number">117</span>
<span class="line-number">118</span># Backward compatibility functions for existing tests
<span class="line-number">119</span>def get_acceptable_encodings() -&gt; list:
<span class="line-number">120</span>    &quot;&quot;&quot;
</pre>
<h4>Line 187</h4>
<pre>
<span class="line-number">182</span>    Returns:
<span class="line-number">183</span>        The default encoding name for the current platform.
<span class="line-number">184</span>    &quot;&quot;&quot;
<span class="line-number">185</span>    import sys
<span class="line-number">186</span>    if sys.platform.startswith(&quot;win&quot;):
<span class="line-number">187</span><span class="uncovered">        return &quot;windows-1252&quot;  # Common Windows default</span>
<span class="line-number">188</span>    else:
<span class="line-number">189</span>        return &quot;utf-8&quot;  # Common Unix/Linux default
</pre>
</div>
<div class="file-section">
<div class="file-header">
/workspace/c_to_plantuml/verifier.py - 84.17% coverage (117/139 lines)
</div>
<h4>Line 67</h4>
<pre>
<span class="line-number"> 62</span>
<span class="line-number"> 63</span>    def _verify_file(self, file_path: str, file_model: FileModel) -&gt; None:
<span class="line-number"> 64</span>        &quot;&quot;&quot;Verify a single file model&quot;&quot;&quot;
<span class="line-number"> 65</span>        # Verify file-level data
<span class="line-number"> 66</span>        if not file_model.file_path or not file_model.file_path.strip():
<span class="line-number"> 67</span><span class="uncovered">            self.issues.append(f&quot;File path is empty in {file_path}&quot;)</span>
<span class="line-number"> 68</span>
<span class="line-number"> 69</span>        if not file_model.relative_path or not file_model.relative_path.strip():
<span class="line-number"> 70</span>            self.issues.append(f&quot;Relative path is empty in {file_path}&quot;)
<span class="line-number"> 71</span>
<span class="line-number"> 72</span>        # Verify structs
</pre>
<h4>Line 70</h4>
<pre>
<span class="line-number"> 65</span>        # Verify file-level data
<span class="line-number"> 66</span>        if not file_model.file_path or not file_model.file_path.strip():
<span class="line-number"> 67</span>            self.issues.append(f&quot;File path is empty in {file_path}&quot;)
<span class="line-number"> 68</span>
<span class="line-number"> 69</span>        if not file_model.relative_path or not file_model.relative_path.strip():
<span class="line-number"> 70</span><span class="uncovered">            self.issues.append(f&quot;Relative path is empty in {file_path}&quot;)</span>
<span class="line-number"> 71</span>
<span class="line-number"> 72</span>        # Verify structs
<span class="line-number"> 73</span>        for struct_name, struct in file_model.structs.items():
<span class="line-number"> 74</span>            self._verify_struct(file_path, struct_name, struct)
<span class="line-number"> 75</span>
</pre>
<h4>Line 111</h4>
<pre>
<span class="line-number">106</span>            self._verify_field(file_path, f&quot;struct {struct_name}&quot;, field)
<span class="line-number">107</span>
<span class="line-number">108</span>    def _verify_enum(self, file_path: str, enum_name: str, enum: Enum) -&gt; None:
<span class="line-number">109</span>        &quot;&quot;&quot;Verify an enum definition&quot;&quot;&quot;
<span class="line-number">110</span>        if not self._is_valid_identifier(enum_name):
<span class="line-number">111</span><span class="uncovered">            self.issues.append(f&quot;Invalid enum name &#x27;{enum_name}&#x27; in {file_path}&quot;)</span>
<span class="line-number">112</span>
<span class="line-number">113</span>        if not enum.name or not enum.name.strip():
<span class="line-number">114</span>            self.issues.append(f&quot;Enum name is empty in {file_path}&quot;)
<span class="line-number">115</span>
<span class="line-number">116</span>        # Verify enum values
</pre>
<h4>Line 114</h4>
<pre>
<span class="line-number">109</span>        &quot;&quot;&quot;Verify an enum definition&quot;&quot;&quot;
<span class="line-number">110</span>        if not self._is_valid_identifier(enum_name):
<span class="line-number">111</span>            self.issues.append(f&quot;Invalid enum name &#x27;{enum_name}&#x27; in {file_path}&quot;)
<span class="line-number">112</span>
<span class="line-number">113</span>        if not enum.name or not enum.name.strip():
<span class="line-number">114</span><span class="uncovered">            self.issues.append(f&quot;Enum name is empty in {file_path}&quot;)</span>
<span class="line-number">115</span>
<span class="line-number">116</span>        # Verify enum values
<span class="line-number">117</span>        for enum_value in enum.values:
<span class="line-number">118</span>            if not enum_value.name or not enum_value.name.strip():
<span class="line-number">119</span>                self.issues.append(
</pre>
<h4>Line 119</h4>
<pre>
<span class="line-number">114</span>            self.issues.append(f&quot;Enum name is empty in {file_path}&quot;)
<span class="line-number">115</span>
<span class="line-number">116</span>        # Verify enum values
<span class="line-number">117</span>        for enum_value in enum.values:
<span class="line-number">118</span>            if not enum_value.name or not enum_value.name.strip():
<span class="line-number">119</span><span class="uncovered">                self.issues.append(</span>
<span class="line-number">120</span>                    f&quot;Enum value name is empty in enum {enum_name} in {file_path}&quot;
<span class="line-number">121</span>                )
<span class="line-number">122</span>            elif not self._is_valid_identifier(enum_value.name):
<span class="line-number">123</span>                self.issues.append(
<span class="line-number">124</span>                    f&quot;Invalid enum value name &#x27;{enum_value.name}&#x27; in enum {enum_name} in {file_path}&quot;
</pre>
<h4>Line 123</h4>
<pre>
<span class="line-number">118</span>            if not enum_value.name or not enum_value.name.strip():
<span class="line-number">119</span>                self.issues.append(
<span class="line-number">120</span>                    f&quot;Enum value name is empty in enum {enum_name} in {file_path}&quot;
<span class="line-number">121</span>                )
<span class="line-number">122</span>            elif not self._is_valid_identifier(enum_value.name):
<span class="line-number">123</span><span class="uncovered">                self.issues.append(</span>
<span class="line-number">124</span>                    f&quot;Invalid enum value name &#x27;{enum_value.name}&#x27; in enum {enum_name} in {file_path}&quot;
<span class="line-number">125</span>                )
<span class="line-number">126</span>
<span class="line-number">127</span>    def _verify_union(self, file_path: str, union_name: str, union: Union) -&gt; None:
<span class="line-number">128</span>        &quot;&quot;&quot;Verify a union definition&quot;&quot;&quot;
</pre>
<h4>Line 130</h4>
<pre>
<span class="line-number">125</span>                )
<span class="line-number">126</span>
<span class="line-number">127</span>    def _verify_union(self, file_path: str, union_name: str, union: Union) -&gt; None:
<span class="line-number">128</span>        &quot;&quot;&quot;Verify a union definition&quot;&quot;&quot;
<span class="line-number">129</span>        if not self._is_valid_identifier(union_name):
<span class="line-number">130</span><span class="uncovered">            self.issues.append(f&quot;Invalid union name &#x27;{union_name}&#x27; in {file_path}&quot;)</span>
<span class="line-number">131</span>
<span class="line-number">132</span>        if not union.name or not union.name.strip():
<span class="line-number">133</span>            self.issues.append(f&quot;Union name is empty in {file_path}&quot;)
<span class="line-number">134</span>
<span class="line-number">135</span>        # Verify fields
</pre>
<h4>Line 133</h4>
<pre>
<span class="line-number">128</span>        &quot;&quot;&quot;Verify a union definition&quot;&quot;&quot;
<span class="line-number">129</span>        if not self._is_valid_identifier(union_name):
<span class="line-number">130</span>            self.issues.append(f&quot;Invalid union name &#x27;{union_name}&#x27; in {file_path}&quot;)
<span class="line-number">131</span>
<span class="line-number">132</span>        if not union.name or not union.name.strip():
<span class="line-number">133</span><span class="uncovered">            self.issues.append(f&quot;Union name is empty in {file_path}&quot;)</span>
<span class="line-number">134</span>
<span class="line-number">135</span>        # Verify fields
<span class="line-number">136</span>        for field in union.fields:
<span class="line-number">137</span>            self._verify_field(file_path, f&quot;union {union_name}&quot;, field)
<span class="line-number">138</span>
</pre>
<h4>Line 142</h4>
<pre>
<span class="line-number">137</span>            self._verify_field(file_path, f&quot;union {union_name}&quot;, field)
<span class="line-number">138</span>
<span class="line-number">139</span>    def _verify_function(self, file_path: str, function: Function) -&gt; None:
<span class="line-number">140</span>        &quot;&quot;&quot;Verify a function definition&quot;&quot;&quot;
<span class="line-number">141</span>        if not function.name or not function.name.strip():
<span class="line-number">142</span><span class="uncovered">            self.issues.append(f&quot;Function name is empty in {file_path}&quot;)</span>
<span class="line-number">143</span>        elif not self._is_valid_identifier(function.name):
<span class="line-number">144</span>            self.issues.append(
<span class="line-number">145</span>                f&quot;Invalid function name &#x27;{function.name}&#x27; in {file_path}&quot;
<span class="line-number">146</span>            )
<span class="line-number">147</span>
</pre>
<h4>Line 144</h4>
<pre>
<span class="line-number">139</span>    def _verify_function(self, file_path: str, function: Function) -&gt; None:
<span class="line-number">140</span>        &quot;&quot;&quot;Verify a function definition&quot;&quot;&quot;
<span class="line-number">141</span>        if not function.name or not function.name.strip():
<span class="line-number">142</span>            self.issues.append(f&quot;Function name is empty in {file_path}&quot;)
<span class="line-number">143</span>        elif not self._is_valid_identifier(function.name):
<span class="line-number">144</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">145</span>                f&quot;Invalid function name &#x27;{function.name}&#x27; in {file_path}&quot;
<span class="line-number">146</span>            )
<span class="line-number">147</span>
<span class="line-number">148</span>        if not function.return_type or not function.return_type.strip():
<span class="line-number">149</span>            self.issues.append(
</pre>
<h4>Line 149</h4>
<pre>
<span class="line-number">144</span>            self.issues.append(
<span class="line-number">145</span>                f&quot;Invalid function name &#x27;{function.name}&#x27; in {file_path}&quot;
<span class="line-number">146</span>            )
<span class="line-number">147</span>
<span class="line-number">148</span>        if not function.return_type or not function.return_type.strip():
<span class="line-number">149</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">150</span>                f&quot;Function return type is empty for &#x27;{function.name}&#x27; in {file_path}&quot;
<span class="line-number">151</span>            )
<span class="line-number">152</span>
<span class="line-number">153</span>        # Verify parameters (skip variadic parameter &#x27;...&#x27;)
<span class="line-number">154</span>        for param in function.parameters:
</pre>
<h4>Line 166</h4>
<pre>
<span class="line-number">161</span>        self._verify_field(file_path, &quot;global&quot;, global_var)
<span class="line-number">162</span>
<span class="line-number">163</span>    def _verify_alias(self, file_path: str, alias_name: str, alias: Alias) -&gt; None:
<span class="line-number">164</span>        &quot;&quot;&quot;Verify a type alias (typedef)&quot;&quot;&quot;
<span class="line-number">165</span>        if not self._is_valid_identifier(alias_name):
<span class="line-number">166</span><span class="uncovered">            self.issues.append(f&quot;Invalid alias name &#x27;{alias_name}&#x27; in {file_path}&quot;)</span>
<span class="line-number">167</span>
<span class="line-number">168</span>        if not alias.name or not alias.name.strip():
<span class="line-number">169</span>            self.issues.append(f&quot;Alias name is empty in {file_path}&quot;)
<span class="line-number">170</span>
<span class="line-number">171</span>        if not alias.original_type or not alias.original_type.strip():
</pre>
<h4>Line 169</h4>
<pre>
<span class="line-number">164</span>        &quot;&quot;&quot;Verify a type alias (typedef)&quot;&quot;&quot;
<span class="line-number">165</span>        if not self._is_valid_identifier(alias_name):
<span class="line-number">166</span>            self.issues.append(f&quot;Invalid alias name &#x27;{alias_name}&#x27; in {file_path}&quot;)
<span class="line-number">167</span>
<span class="line-number">168</span>        if not alias.name or not alias.name.strip():
<span class="line-number">169</span><span class="uncovered">            self.issues.append(f&quot;Alias name is empty in {file_path}&quot;)</span>
<span class="line-number">170</span>
<span class="line-number">171</span>        if not alias.original_type or not alias.original_type.strip():
<span class="line-number">172</span>            self.issues.append(
<span class="line-number">173</span>                f&quot;Alias original type is empty for &#x27;{alias_name}&#x27; in {file_path}&quot;
<span class="line-number">174</span>            )
</pre>
<h4>Line 172</h4>
<pre>
<span class="line-number">167</span>
<span class="line-number">168</span>        if not alias.name or not alias.name.strip():
<span class="line-number">169</span>            self.issues.append(f&quot;Alias name is empty in {file_path}&quot;)
<span class="line-number">170</span>
<span class="line-number">171</span>        if not alias.original_type or not alias.original_type.strip():
<span class="line-number">172</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">173</span>                f&quot;Alias original type is empty for &#x27;{alias_name}&#x27; in {file_path}&quot;
<span class="line-number">174</span>            )
<span class="line-number">175</span>
<span class="line-number">176</span>    def _verify_field(self, file_path: str, context: str, field: Field) -&gt; None:
<span class="line-number">177</span>        &quot;&quot;&quot;Verify a field (struct field, function parameter, global variable)&quot;&quot;&quot;
</pre>
<h4>Line 180</h4>
<pre>
<span class="line-number">175</span>
<span class="line-number">176</span>    def _verify_field(self, file_path: str, context: str, field: Field) -&gt; None:
<span class="line-number">177</span>        &quot;&quot;&quot;Verify a field (struct field, function parameter, global variable)&quot;&quot;&quot;
<span class="line-number">178</span>        # Check for invalid names
<span class="line-number">179</span>        if not field.name or not field.name.strip():
<span class="line-number">180</span><span class="uncovered">            self.issues.append(f&quot;Field name is empty in {context} in {file_path}&quot;)</span>
<span class="line-number">181</span>        elif not self._is_valid_identifier(field.name):
<span class="line-number">182</span>            self.issues.append(
<span class="line-number">183</span>                f&quot;Invalid field name &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">184</span>            )
<span class="line-number">185</span>
</pre>
<h4>Line 188</h4>
<pre>
<span class="line-number">183</span>                f&quot;Invalid field name &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">184</span>            )
<span class="line-number">185</span>
<span class="line-number">186</span>        # Check for invalid types
<span class="line-number">187</span>        if not field.type or not field.type.strip():
<span class="line-number">188</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">189</span>                f&quot;Field type is empty for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">190</span>            )
<span class="line-number">191</span>        elif self._is_suspicious_type(field.type):
<span class="line-number">192</span>            self.issues.append(
<span class="line-number">193</span>                f&quot;Suspicious field type &#x27;{field.type}&#x27; for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
</pre>
<h4>Line 213</h4>
<pre>
<span class="line-number">208</span>        return bool(re.match(r&quot;^[a-zA-Z_][a-zA-Z0-9_]*$&quot;, name.strip()))
<span class="line-number">209</span>
<span class="line-number">210</span>    def _is_suspicious_type(self, type_str: str) -&gt; bool:
<span class="line-number">211</span>        &quot;&quot;&quot;Check if a type string looks suspicious&quot;&quot;&quot;
<span class="line-number">212</span>        if not type_str or not type_str.strip():
<span class="line-number">213</span><span class="uncovered">            return True</span>
<span class="line-number">214</span>
<span class="line-number">215</span>        type_str = type_str.strip()
<span class="line-number">216</span>
<span class="line-number">217</span>        # Check for obvious parsing errors
<span class="line-number">218</span>        suspicious_patterns = [
</pre>
<h4>Line 227</h4>
<pre>
<span class="line-number">222</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*$&quot;,  # Excessive brackets/whitespace
<span class="line-number">223</span>        ]
<span class="line-number">224</span>
<span class="line-number">225</span>        for pattern in suspicious_patterns:
<span class="line-number">226</span>            if re.match(pattern, type_str):
<span class="line-number">227</span><span class="uncovered">                return True</span>
<span class="line-number">228</span>
<span class="line-number">229</span>        # Check for unbalanced brackets
<span class="line-number">230</span>        if self._has_unbalanced_brackets(type_str):
<span class="line-number">231</span>            return True
<span class="line-number">232</span>
</pre>
<h4>Line 235</h4>
<pre>
<span class="line-number">230</span>        if self._has_unbalanced_brackets(type_str):
<span class="line-number">231</span>            return True
<span class="line-number">232</span>
<span class="line-number">233</span>        # Check for excessive newlines or backslashes
<span class="line-number">234</span>        if type_str.count(&quot;\n&quot;) &gt; 5 or type_str.count(&quot;\\&quot;) &gt; 10:
<span class="line-number">235</span><span class="uncovered">            return True</span>
<span class="line-number">236</span>
<span class="line-number">237</span>        return False
<span class="line-number">238</span>
<span class="line-number">239</span>    def _is_suspicious_value(self, value: str) -&gt; bool:
<span class="line-number">240</span>        &quot;&quot;&quot;Check if a value string looks suspicious&quot;&quot;&quot;
</pre>
<h4>Line 242</h4>
<pre>
<span class="line-number">237</span>        return False
<span class="line-number">238</span>
<span class="line-number">239</span>    def _is_suspicious_value(self, value: str) -&gt; bool:
<span class="line-number">240</span>        &quot;&quot;&quot;Check if a value string looks suspicious&quot;&quot;&quot;
<span class="line-number">241</span>        if not value or not value.strip():
<span class="line-number">242</span><span class="uncovered">            return True</span>
<span class="line-number">243</span>
<span class="line-number">244</span>        value = value.strip()
<span class="line-number">245</span>
<span class="line-number">246</span>        # Check for obvious parsing errors
<span class="line-number">247</span>        suspicious_patterns = [
</pre>
<h4>Line 254</h4>
<pre>
<span class="line-number">249</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Mostly brackets and whitespace
<span class="line-number">250</span>        ]
<span class="line-number">251</span>
<span class="line-number">252</span>        for pattern in suspicious_patterns:
<span class="line-number">253</span>            if re.match(pattern, value):
<span class="line-number">254</span><span class="uncovered">                return True</span>
<span class="line-number">255</span>
<span class="line-number">256</span>        # Check for unbalanced brackets
<span class="line-number">257</span>        if self._has_unbalanced_brackets(value):
<span class="line-number">258</span>            return True
<span class="line-number">259</span>
</pre>
<h4>Line 262</h4>
<pre>
<span class="line-number">257</span>        if self._has_unbalanced_brackets(value):
<span class="line-number">258</span>            return True
<span class="line-number">259</span>
<span class="line-number">260</span>        # Check for excessive newlines or backslashes
<span class="line-number">261</span>        if value.count(&quot;\n&quot;) &gt; 3 or value.count(&quot;\\&quot;) &gt; 5:
<span class="line-number">262</span><span class="uncovered">            return True</span>
<span class="line-number">263</span>
<span class="line-number">264</span>        return False
<span class="line-number">265</span>
<span class="line-number">266</span>    def _has_unbalanced_brackets(self, text: str) -&gt; bool:
<span class="line-number">267</span>        &quot;&quot;&quot;Check if text has unbalanced brackets&quot;&quot;&quot;
</pre>
</div>
<div class="file-section">
<div class="file-header">
/workspace/c_to_plantuml/parser.py - 87.39% coverage (617/706 lines)
</div>
<h4>Lines 21-22</h4>
<pre>
<span class="line-number"> 16</span>)
<span class="line-number"> 17</span>from .preprocessor import PreprocessorManager
<span class="line-number"> 18</span>from .utils import detect_file_encoding
<span class="line-number"> 19</span>
<span class="line-number"> 20</span>if TYPE_CHECKING:
<span class="line-number"> 21</span><span class="uncovered">    from .models import Struct, Enum, Union, Function, Field, Alias</span>
<span class="line-number"> 22</span><span class="uncovered">    from .config import Config</span>
<span class="line-number"> 23</span>
<span class="line-number"> 24</span>
<span class="line-number"> 25</span>class CParser:
<span class="line-number"> 26</span>    &quot;&quot;&quot;C/C++ parser for extracting structural information from source code using tokenization&quot;&quot;&quot;
<span class="line-number"> 27</span>
</pre>
<h4>Line 45</h4>
<pre>
<span class="line-number"> 40</span>
<span class="line-number"> 41</span>        if not project_root.exists():
<span class="line-number"> 42</span>            raise ValueError(f&quot;Project root not found: {project_root}&quot;)
<span class="line-number"> 43</span>
<span class="line-number"> 44</span>        if not project_root.is_dir():
<span class="line-number"> 45</span><span class="uncovered">            raise ValueError(f&quot;Project root must be a directory: {project_root}&quot;)</span>
<span class="line-number"> 46</span>
<span class="line-number"> 47</span>        # Clear the failed includes cache for this new project
<span class="line-number"> 48</span>        cache_size_before = len(self._failed_includes_cache)
<span class="line-number"> 49</span>        self._failed_includes_cache.clear()
<span class="line-number"> 50</span>        if cache_size_before &gt; 0:
</pre>
<h4>Line 51</h4>
<pre>
<span class="line-number"> 46</span>
<span class="line-number"> 47</span>        # Clear the failed includes cache for this new project
<span class="line-number"> 48</span>        cache_size_before = len(self._failed_includes_cache)
<span class="line-number"> 49</span>        self._failed_includes_cache.clear()
<span class="line-number"> 50</span>        if cache_size_before &gt; 0:
<span class="line-number"> 51</span><span class="uncovered">            self.logger.debug(</span>
<span class="line-number"> 52</span>                &quot;Cleared failed includes cache (%d entries)&quot;, cache_size_before
<span class="line-number"> 53</span>            )
<span class="line-number"> 54</span>
<span class="line-number"> 55</span>        self.logger.info(&quot;Parsing project: %s&quot;, project_root)
<span class="line-number"> 56</span>
</pre>
<h4>Lines 82-84</h4>
<pre>
<span class="line-number"> 77</span>                )
<span class="line-number"> 78</span>                files[relative_path] = file_model
<span class="line-number"> 79</span>
<span class="line-number"> 80</span>                self.logger.debug(&quot;Successfully parsed: %s&quot;, relative_path)
<span class="line-number"> 81</span>
<span class="line-number"> 82</span><span class="uncovered">            except (OSError, ValueError) as e:</span>
<span class="line-number"> 83</span><span class="uncovered">                self.logger.warning(&quot;Failed to parse %s: %s&quot;, file_path, e)</span>
<span class="line-number"> 84</span><span class="uncovered">                failed_files.append(str(file_path))</span>
<span class="line-number"> 85</span>
<span class="line-number"> 86</span>        if failed_files:
<span class="line-number"> 87</span>            error_msg = (
<span class="line-number"> 88</span>                f&quot;Failed to parse {len(failed_files)} files: {failed_files}. &quot;
<span class="line-number"> 89</span>                &quot;Stopping model processing.&quot;
</pre>
<h4>Line 87</h4>
<pre>
<span class="line-number"> 82</span>            except (OSError, ValueError) as e:
<span class="line-number"> 83</span>                self.logger.warning(&quot;Failed to parse %s: %s&quot;, file_path, e)
<span class="line-number"> 84</span>                failed_files.append(str(file_path))
<span class="line-number"> 85</span>
<span class="line-number"> 86</span>        if failed_files:
<span class="line-number"> 87</span><span class="uncovered">            error_msg = (</span>
<span class="line-number"> 88</span>                f&quot;Failed to parse {len(failed_files)} files: {failed_files}. &quot;
<span class="line-number"> 89</span>                &quot;Stopping model processing.&quot;
<span class="line-number"> 90</span>            )
<span class="line-number"> 91</span>            self.logger.error(error_msg)
<span class="line-number"> 92</span>            raise RuntimeError(error_msg)
</pre>
<h4>Lines 91-92</h4>
<pre>
<span class="line-number"> 86</span>        if failed_files:
<span class="line-number"> 87</span>            error_msg = (
<span class="line-number"> 88</span>                f&quot;Failed to parse {len(failed_files)} files: {failed_files}. &quot;
<span class="line-number"> 89</span>                &quot;Stopping model processing.&quot;
<span class="line-number"> 90</span>            )
<span class="line-number"> 91</span><span class="uncovered">            self.logger.error(error_msg)</span>
<span class="line-number"> 92</span><span class="uncovered">            raise RuntimeError(error_msg)</span>
<span class="line-number"> 93</span>
<span class="line-number"> 94</span>        model = ProjectModel(
<span class="line-number"> 95</span>            project_name=project_root.name,
<span class="line-number"> 96</span>            project_root=str(project_root),
<span class="line-number"> 97</span>            files=files,
</pre>
<h4>Lines 206-207</h4>
<pre>
<span class="line-number">201</span>                # Convert to Field objects
<span class="line-number">202</span>                fields = []
<span class="line-number">203</span>                for field_name, field_type in field_tuples:
<span class="line-number">204</span>                    try:
<span class="line-number">205</span>                        fields.append(Field(field_name, field_type))
<span class="line-number">206</span><span class="uncovered">                    except ValueError as e:</span>
<span class="line-number">207</span><span class="uncovered">                        self.logger.warning(</span>
<span class="line-number">208</span>                            &quot;Error creating field %s: %s&quot;, field_name, e
<span class="line-number">209</span>                        )
<span class="line-number">210</span>
<span class="line-number">211</span>                # For anonymous structs, use a special key that can be mapped later
<span class="line-number">212</span>                if not struct_name:
</pre>
<h4>Lines 306-307</h4>
<pre>
<span class="line-number">301</span>                # Convert to Field objects
<span class="line-number">302</span>                fields = []
<span class="line-number">303</span>                for field_name, field_type in field_tuples:
<span class="line-number">304</span>                    try:
<span class="line-number">305</span>                        fields.append(Field(field_name, field_type))
<span class="line-number">306</span><span class="uncovered">                    except ValueError as e:</span>
<span class="line-number">307</span><span class="uncovered">                        self.logger.warning(</span>
<span class="line-number">308</span>                            &quot;Error creating union field %s: %s&quot;, field_name, e
<span class="line-number">309</span>                        )
<span class="line-number">310</span>
<span class="line-number">311</span>                # For anonymous unions, use a special key that can be mapped later
<span class="line-number">312</span>                if not union_name:
</pre>
<h4>Line 313</h4>
<pre>
<span class="line-number">308</span>                            &quot;Error creating union field %s: %s&quot;, field_name, e
<span class="line-number">309</span>                        )
<span class="line-number">310</span>
<span class="line-number">311</span>                # For anonymous unions, use a special key that can be mapped later
<span class="line-number">312</span>                if not union_name:
<span class="line-number">313</span><span class="uncovered">                    union_name = &quot;__anonymous_union__&quot;</span>
<span class="line-number">314</span>
<span class="line-number">315</span>                # Extract tag name if this is a typedef union
<span class="line-number">316</span>                tag_name = &quot;&quot;
<span class="line-number">317</span>                if union_name and not union_name.startswith(&quot;__anonymous&quot;):
<span class="line-number">318</span>                    # Check if this union has a typedef
</pre>
<h4>Lines 370-371</h4>
<pre>
<span class="line-number">365</span>                function.is_declaration = is_declaration
<span class="line-number">366</span>                functions.append(function)
<span class="line-number">367</span>                self.logger.debug(
<span class="line-number">368</span>                    f&quot;Parsed function: {func_name} with {len(parameters)} parameters (declaration: {is_declaration})&quot;
<span class="line-number">369</span>                )
<span class="line-number">370</span><span class="uncovered">            except Exception as e:</span>
<span class="line-number">371</span><span class="uncovered">                self.logger.warning(&quot;Error creating function %s: %s&quot;, func_name, e)</span>
<span class="line-number">372</span>
<span class="line-number">373</span>        return functions
<span class="line-number">374</span>
<span class="line-number">375</span>    def _parse_globals_with_tokenizer(self, tokens) -&gt; List[&quot;Field&quot;]:
<span class="line-number">376</span>        &quot;&quot;&quot;Parse global variables using tokenizer&quot;&quot;&quot;
</pre>
<h4>Lines 396-397</h4>
<pre>
<span class="line-number">391</span>                i += 1
<span class="line-number">392</span>                continue
<span class="line-number">393</span>
<span class="line-number">394</span>            # Skip preprocessor directives but keep their content
<span class="line-number">395</span>            if tokens[i].type == TokenType.PREPROCESSOR:
<span class="line-number">396</span><span class="uncovered">                i = self._skip_preprocessor_directives(tokens, i)</span>
<span class="line-number">397</span><span class="uncovered">                continue</span>
<span class="line-number">398</span>
<span class="line-number">399</span>            # Skip function definitions (look for parentheses)
<span class="line-number">400</span>            if self._looks_like_function(tokens, i):
<span class="line-number">401</span>                i = self._skip_function(tokens, i)
<span class="line-number">402</span>                continue
</pre>
<h4>Lines 417-426</h4>
<pre>
<span class="line-number">412</span>                continue
<span class="line-number">413</span>
<span class="line-number">414</span>            # Skip if we&#x27;re inside a struct definition (look for opening brace)
<span class="line-number">415</span>            if i &gt; 0 and tokens[i - 1].type == TokenType.LBRACE:
<span class="line-number">416</span>                # We&#x27;re inside a struct, skip until closing brace
<span class="line-number">417</span><span class="uncovered">                brace_count = 1</span>
<span class="line-number">418</span><span class="uncovered">                j = i</span>
<span class="line-number">419</span><span class="uncovered">                while j &lt; len(tokens) and brace_count &gt; 0:</span>
<span class="line-number">420</span><span class="uncovered">                    if tokens[j].type == TokenType.LBRACE:</span>
<span class="line-number">421</span><span class="uncovered">                        brace_count += 1</span>
<span class="line-number">422</span><span class="uncovered">                    elif tokens[j].type == TokenType.RBRACE:</span>
<span class="line-number">423</span><span class="uncovered">                        brace_count -= 1</span>
<span class="line-number">424</span><span class="uncovered">                    j += 1</span>
<span class="line-number">425</span><span class="uncovered">                i = j</span>
<span class="line-number">426</span><span class="uncovered">                continue</span>
<span class="line-number">427</span>
<span class="line-number">428</span>            # Skip macros and other preprocessor content
<span class="line-number">429</span>            if tokens[i].type == TokenType.DEFINE:
<span class="line-number">430</span>                # Skip the entire macro content (multi-line macros are now merged)
<span class="line-number">431</span>                i += 1
</pre>
<h4>Lines 431-432</h4>
<pre>
<span class="line-number">426</span>                continue
<span class="line-number">427</span>
<span class="line-number">428</span>            # Skip macros and other preprocessor content
<span class="line-number">429</span>            if tokens[i].type == TokenType.DEFINE:
<span class="line-number">430</span>                # Skip the entire macro content (multi-line macros are now merged)
<span class="line-number">431</span><span class="uncovered">                i += 1</span>
<span class="line-number">432</span><span class="uncovered">                continue</span>
<span class="line-number">433</span>
<span class="line-number">434</span>            # Additional check: skip if we&#x27;re inside any brace block (struct, function, etc.)
<span class="line-number">435</span>            brace_count = 0
<span class="line-number">436</span>            j = i - 1
<span class="line-number">437</span>            while j &gt;= 0:
</pre>
<h4>Lines 480-481</h4>
<pre>
<span class="line-number">475</span>                                    )
<span class="line-number">476</span>                                )
<span class="line-number">477</span>                                self.logger.debug(
<span class="line-number">478</span>                                    f&quot;Parsed global: {stripped_name} : {stripped_type}&quot;
<span class="line-number">479</span>                                )
<span class="line-number">480</span><span class="uncovered">                        except Exception as e:</span>
<span class="line-number">481</span><span class="uncovered">                            self.logger.warning(</span>
<span class="line-number">482</span>                                f&quot;Error creating global field {var_name}: {e}&quot;
<span class="line-number">483</span>                            )
<span class="line-number">484</span>                    i = self._skip_to_semicolon(tokens, i)
<span class="line-number">485</span>                else:
<span class="line-number">486</span>                    i += 1
</pre>
<h4>Line 609</h4>
<pre>
<span class="line-number">604</span>    def _extract_non_primitive_types(
<span class="line-number">605</span>        self, type_str: str, available_types: Set[str]
<span class="line-number">606</span>    ) -&gt; List[str]:
<span class="line-number">607</span>        &quot;&quot;&quot;Extract non-primitive type names from a type string that exist in available_types&quot;&quot;&quot;
<span class="line-number">608</span>        # Define primitive types
<span class="line-number">609</span><span class="uncovered">        primitive_types = {</span>
<span class="line-number">610</span>            &quot;void&quot;,
<span class="line-number">611</span>            &quot;char&quot;,
<span class="line-number">612</span>            &quot;short&quot;,
<span class="line-number">613</span>            &quot;int&quot;,
<span class="line-number">614</span>            &quot;long&quot;,
</pre>
<h4>Line 647</h4>
<pre>
<span class="line-number">642</span>            &quot;NULL&quot;,
<span class="line-number">643</span>            &quot;nullptr&quot;,
<span class="line-number">644</span>        }
<span class="line-number">645</span>
<span class="line-number">646</span>        # Remove common C keywords and operators
<span class="line-number">647</span><span class="uncovered">        import re</span>
<span class="line-number">648</span>
<span class="line-number">649</span>        # Split by common delimiters and operators
<span class="line-number">650</span>        parts = re.split(r&quot;[\[\]\(\)\{\}\s\*&amp;,;]&quot;, type_str)
<span class="line-number">651</span>
<span class="line-number">652</span>        # Extract potential type names that exist in available_types
</pre>
<h4>Line 650</h4>
<pre>
<span class="line-number">645</span>
<span class="line-number">646</span>        # Remove common C keywords and operators
<span class="line-number">647</span>        import re
<span class="line-number">648</span>
<span class="line-number">649</span>        # Split by common delimiters and operators
<span class="line-number">650</span><span class="uncovered">        parts = re.split(r&quot;[\[\]\(\)\{\}\s\*&amp;,;]&quot;, type_str)</span>
<span class="line-number">651</span>
<span class="line-number">652</span>        # Extract potential type names that exist in available_types
<span class="line-number">653</span>        types = []
<span class="line-number">654</span>        for part in parts:
<span class="line-number">655</span>            part = part.strip()
</pre>
<h4>Lines 653-656</h4>
<pre>
<span class="line-number">648</span>
<span class="line-number">649</span>        # Split by common delimiters and operators
<span class="line-number">650</span>        parts = re.split(r&quot;[\[\]\(\)\{\}\s\*&amp;,;]&quot;, type_str)
<span class="line-number">651</span>
<span class="line-number">652</span>        # Extract potential type names that exist in available_types
<span class="line-number">653</span><span class="uncovered">        types = []</span>
<span class="line-number">654</span><span class="uncovered">        for part in parts:</span>
<span class="line-number">655</span><span class="uncovered">            part = part.strip()</span>
<span class="line-number">656</span><span class="uncovered">            if part and len(part) &gt; 1 and part not in primitive_types:</span>
<span class="line-number">657</span>                # Check if it looks like a type name (starts with letter, contains letters/numbers/underscores)
<span class="line-number">658</span>                if re.match(r&quot;^[a-zA-Z_][a-zA-Z0-9_]*$&quot;, part):
<span class="line-number">659</span>                    # Only include if it exists in available_types
<span class="line-number">660</span>                    if part in available_types:
<span class="line-number">661</span>                        types.append(part)
</pre>
<h4>Line 658</h4>
<pre>
<span class="line-number">653</span>        types = []
<span class="line-number">654</span>        for part in parts:
<span class="line-number">655</span>            part = part.strip()
<span class="line-number">656</span>            if part and len(part) &gt; 1 and part not in primitive_types:
<span class="line-number">657</span>                # Check if it looks like a type name (starts with letter, contains letters/numbers/underscores)
<span class="line-number">658</span><span class="uncovered">                if re.match(r&quot;^[a-zA-Z_][a-zA-Z0-9_]*$&quot;, part):</span>
<span class="line-number">659</span>                    # Only include if it exists in available_types
<span class="line-number">660</span>                    if part in available_types:
<span class="line-number">661</span>                        types.append(part)
<span class="line-number">662</span>
<span class="line-number">663</span>        return list(set(types))  # Remove duplicates
</pre>
<h4>Lines 660-661</h4>
<pre>
<span class="line-number">655</span>            part = part.strip()
<span class="line-number">656</span>            if part and len(part) &gt; 1 and part not in primitive_types:
<span class="line-number">657</span>                # Check if it looks like a type name (starts with letter, contains letters/numbers/underscores)
<span class="line-number">658</span>                if re.match(r&quot;^[a-zA-Z_][a-zA-Z0-9_]*$&quot;, part):
<span class="line-number">659</span>                    # Only include if it exists in available_types
<span class="line-number">660</span><span class="uncovered">                    if part in available_types:</span>
<span class="line-number">661</span><span class="uncovered">                        types.append(part)</span>
<span class="line-number">662</span>
<span class="line-number">663</span>        return list(set(types))  # Remove duplicates
<span class="line-number">664</span>
<span class="line-number">665</span>    def _find_c_files(self, project_root: Path, recursive_search: bool) -&gt; List[Path]:
<span class="line-number">666</span>        &quot;&quot;&quot;Find all C/C++ files in the project&quot;&quot;&quot;
</pre>
<h4>Line 663</h4>
<pre>
<span class="line-number">658</span>                if re.match(r&quot;^[a-zA-Z_][a-zA-Z0-9_]*$&quot;, part):
<span class="line-number">659</span>                    # Only include if it exists in available_types
<span class="line-number">660</span>                    if part in available_types:
<span class="line-number">661</span>                        types.append(part)
<span class="line-number">662</span>
<span class="line-number">663</span><span class="uncovered">        return list(set(types))  # Remove duplicates</span>
<span class="line-number">664</span>
<span class="line-number">665</span>    def _find_c_files(self, project_root: Path, recursive_search: bool) -&gt; List[Path]:
<span class="line-number">666</span>        &quot;&quot;&quot;Find all C/C++ files in the project&quot;&quot;&quot;
<span class="line-number">667</span>        c_extensions = {&quot;.c&quot;, &quot;.h&quot;, &quot;.cpp&quot;, &quot;.cc&quot;, &quot;.cxx&quot;, &quot;.hpp&quot;, &quot;.hxx&quot;}
<span class="line-number">668</span>        files = []
</pre>
<h4>Lines 676-677</h4>
<pre>
<span class="line-number">671</span>
<span class="line-number">672</span>        if recursive_search:
<span class="line-number">673</span>            for ext in c_extensions:
<span class="line-number">674</span>                files.extend(project_root.rglob(f&quot;*{ext}&quot;))
<span class="line-number">675</span>        else:
<span class="line-number">676</span><span class="uncovered">            for ext in c_extensions:</span>
<span class="line-number">677</span><span class="uncovered">                files.extend(project_root.glob(f&quot;*{ext}&quot;))</span>
<span class="line-number">678</span>
<span class="line-number">679</span>        # Filter out hidden files and common exclude patterns
<span class="line-number">680</span>        filtered_files = []
<span class="line-number">681</span>        exclude_patterns = {&quot;.git&quot;, &quot;__pycache__&quot;, &quot;node_modules&quot;, &quot;.vscode&quot;, &quot;.idea&quot;}
<span class="line-number">682</span>
</pre>
<h4>Line 686</h4>
<pre>
<span class="line-number">681</span>        exclude_patterns = {&quot;.git&quot;, &quot;__pycache__&quot;, &quot;node_modules&quot;, &quot;.vscode&quot;, &quot;.idea&quot;}
<span class="line-number">682</span>
<span class="line-number">683</span>        for file_path in files:
<span class="line-number">684</span>            # Skip hidden files and directories
<span class="line-number">685</span>            if any(part.startswith(&quot;.&quot;) for part in file_path.parts):
<span class="line-number">686</span><span class="uncovered">                continue</span>
<span class="line-number">687</span>
<span class="line-number">688</span>            # Skip common exclude patterns
<span class="line-number">689</span>            if any(pattern in file_path.parts for pattern in exclude_patterns):
<span class="line-number">690</span>                continue
<span class="line-number">691</span>
</pre>
<h4>Line 690</h4>
<pre>
<span class="line-number">685</span>            if any(part.startswith(&quot;.&quot;) for part in file_path.parts):
<span class="line-number">686</span>                continue
<span class="line-number">687</span>
<span class="line-number">688</span>            # Skip common exclude patterns
<span class="line-number">689</span>            if any(pattern in file_path.parts for pattern in exclude_patterns):
<span class="line-number">690</span><span class="uncovered">                continue</span>
<span class="line-number">691</span>
<span class="line-number">692</span>            filtered_files.append(file_path)
<span class="line-number">693</span>
<span class="line-number">694</span>        self.logger.debug(&quot;Found %d C/C++ files after filtering&quot;, len(filtered_files))
<span class="line-number">695</span>        return sorted(filtered_files)
</pre>
<h4>Line 704</h4>
<pre>
<span class="line-number">699</span>    ) -&gt; List[Path]:
<span class="line-number">700</span>        &quot;&quot;&quot;Find C/C++ files based on configuration and include dependencies&quot;&quot;&quot;
<span class="line-number">701</span>
<span class="line-number">702</span>        # If no config provided, fall back to old behavior
<span class="line-number">703</span>        if config is None:
<span class="line-number">704</span><span class="uncovered">            return self._find_c_files(project_root, recursive_search)</span>
<span class="line-number">705</span>
<span class="line-number">706</span>        # Get include depth from config
<span class="line-number">707</span>        include_depth = getattr(config, &quot;include_depth&quot;, 1)
<span class="line-number">708</span>        self.logger.info(&quot;Using include depth: %d&quot;, include_depth)
<span class="line-number">709</span>
</pre>
<h4>Line 739</h4>
<pre>
<span class="line-number">734</span>        )
<span class="line-number">735</span>        self.logger.debug(&quot;Initial C files: %s&quot;, [f.name for f in initial_c_files])
<span class="line-number">736</span>
<span class="line-number">737</span>        # Step 3: If include_depth is 0, return only the initially filtered C files
<span class="line-number">738</span>        if include_depth == 0:
<span class="line-number">739</span><span class="uncovered">            return initial_c_files</span>
<span class="line-number">740</span>
<span class="line-number">741</span>        # Step 4: Process include dependencies for N iterations
<span class="line-number">742</span>        files_to_parse = set(initial_c_files)
<span class="line-number">743</span>
<span class="line-number">744</span>        for iteration in range(include_depth):
</pre>
<h4>Line 776</h4>
<pre>
<span class="line-number">771</span>                            new_includes.add(included_file)
<span class="line-number">772</span>                            self.logger.debug(
<span class="line-number">773</span>                                f&quot;Added included file in iteration {iteration + 1}: {relative_included_path}&quot;
<span class="line-number">774</span>                            )
<span class="line-number">775</span>                        else:
<span class="line-number">776</span><span class="uncovered">                            self.logger.debug(</span>
<span class="line-number">777</span>                                f&quot;Excluded included file due to config: {relative_included_path}&quot;
<span class="line-number">778</span>                            )
<span class="line-number">779</span>                    elif included_file:
<span class="line-number">780</span>                        self.logger.debug(
<span class="line-number">781</span>                            f&quot;Included file already in list: {included_file.name}&quot;
</pre>
<h4>Line 848</h4>
<pre>
<span class="line-number">843</span>                    if include_name.endswith(ext)
<span class="line-number">844</span>                    else f&quot;{include_name}{ext}&quot;
<span class="line-number">845</span>                )
<span class="line-number">846</span>                # Search recursively in project root
<span class="line-number">847</span>                for found_file in project_root.rglob(full_name):
<span class="line-number">848</span><span class="uncovered">                    if found_file.is_file():</span>
<span class="line-number">849</span>                        # For backward compatibility with tests, return full path if it&#x27;s a test
<span class="line-number">850</span>                        # Otherwise return filename for simplified tracking
<span class="line-number">851</span>                        if &quot;tmp&quot; in str(found_file):
<span class="line-number">852</span>                            return found_file
<span class="line-number">853</span>                        else:
</pre>
<h4>Lines 851-852</h4>
<pre>
<span class="line-number">846</span>                # Search recursively in project root
<span class="line-number">847</span>                for found_file in project_root.rglob(full_name):
<span class="line-number">848</span>                    if found_file.is_file():
<span class="line-number">849</span>                        # For backward compatibility with tests, return full path if it&#x27;s a test
<span class="line-number">850</span>                        # Otherwise return filename for simplified tracking
<span class="line-number">851</span><span class="uncovered">                        if &quot;tmp&quot; in str(found_file):</span>
<span class="line-number">852</span><span class="uncovered">                            return found_file</span>
<span class="line-number">853</span>                        else:
<span class="line-number">854</span>                            return found_file
<span class="line-number">855</span>
<span class="line-number">856</span>        # If we get here, the file was not found - cache this result
<span class="line-number">857</span>        self._failed_includes_cache.add(cache_key)
</pre>
<h4>Line 854</h4>
<pre>
<span class="line-number">849</span>                        # For backward compatibility with tests, return full path if it&#x27;s a test
<span class="line-number">850</span>                        # Otherwise return filename for simplified tracking
<span class="line-number">851</span>                        if &quot;tmp&quot; in str(found_file):
<span class="line-number">852</span>                            return found_file
<span class="line-number">853</span>                        else:
<span class="line-number">854</span><span class="uncovered">                            return found_file</span>
<span class="line-number">855</span>
<span class="line-number">856</span>        # If we get here, the file was not found - cache this result
<span class="line-number">857</span>        self._failed_includes_cache.add(cache_key)
<span class="line-number">858</span>        self.logger.debug(&quot;Cached failed include search for &#x27;%s&#x27;&quot;, include_name)
<span class="line-number">859</span>        return None
</pre>
<h4>Lines 872-874</h4>
<pre>
<span class="line-number">867</span>
<span class="line-number">868</span>            # Tokenize and extract includes
<span class="line-number">869</span>            tokens = self.tokenizer.tokenize(content)
<span class="line-number">870</span>            return self._parse_includes_with_tokenizer(tokens)
<span class="line-number">871</span>
<span class="line-number">872</span><span class="uncovered">        except Exception as e:</span>
<span class="line-number">873</span><span class="uncovered">            self.logger.warning(&quot;Failed to extract includes from %s: %s&quot;, file_path, e)</span>
<span class="line-number">874</span><span class="uncovered">            return []</span>
<span class="line-number">875</span>
<span class="line-number">876</span>    def _detect_encoding(self, file_path: Path) -&gt; str:
<span class="line-number">877</span>        &quot;&quot;&quot;Detect file encoding with platform-aware fallbacks&quot;&quot;&quot;
<span class="line-number">878</span>        return detect_file_encoding(file_path)
<span class="line-number">879</span>
</pre>
<h4>Line 896</h4>
<pre>
<span class="line-number">891</span>                and token.column == target_token.column
<span class="line-number">892</span>                and token.value == target_token.value
<span class="line-number">893</span>            ):
<span class="line-number">894</span>                return i
<span class="line-number">895</span>
<span class="line-number">896</span><span class="uncovered">        return None</span>
<span class="line-number">897</span>
<span class="line-number">898</span>    def _parse_single_typedef(self, tokens, start_pos):
<span class="line-number">899</span>        &quot;&quot;&quot;Parse a single typedef starting at the given position&quot;&quot;&quot;
<span class="line-number">900</span>        # Skip &#x27;typedef&#x27; keyword
<span class="line-number">901</span>        pos = start_pos + 1
</pre>
<h4>Line 911</h4>
<pre>
<span class="line-number">906</span>            TokenType.COMMENT,
<span class="line-number">907</span>        ]:
<span class="line-number">908</span>            pos += 1
<span class="line-number">909</span>
<span class="line-number">910</span>        if pos &gt;= len(tokens):
<span class="line-number">911</span><span class="uncovered">            return None</span>
<span class="line-number">912</span>
<span class="line-number">913</span>        # Check if it&#x27;s a struct/enum/union typedef (we&#x27;ll handle these separately)
<span class="line-number">914</span>        if tokens[pos].type in [TokenType.STRUCT, TokenType.ENUM, TokenType.UNION]:
<span class="line-number">915</span>            return self._parse_complex_typedef(tokens, pos)
<span class="line-number">916</span>
</pre>
<h4>Line 925</h4>
<pre>
<span class="line-number">920</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">921</span>                all_tokens.append(tokens[pos])
<span class="line-number">922</span>            pos += 1
<span class="line-number">923</span>
<span class="line-number">924</span>        if len(all_tokens) &lt; 2:
<span class="line-number">925</span><span class="uncovered">            return None</span>
<span class="line-number">926</span>
<span class="line-number">927</span>        # Function pointer typedef: typedef ret (*name)(params);
<span class="line-number">928</span>        for i in range(len(all_tokens) - 3):
<span class="line-number">929</span>            if (
<span class="line-number">930</span>                all_tokens[i].type
</pre>
<h4>Lines 959-961</h4>
<pre>
<span class="line-number">954</span>            if (
<span class="line-number">955</span>                all_tokens[i].type == TokenType.LBRACKET
<span class="line-number">956</span>                and i &gt; 0
<span class="line-number">957</span>                and all_tokens[i - 1].type == TokenType.IDENTIFIER
<span class="line-number">958</span>            ):
<span class="line-number">959</span><span class="uncovered">                typedef_name = all_tokens[i - 1].value</span>
<span class="line-number">960</span><span class="uncovered">                original_type = &quot; &quot;.join(t.value for t in all_tokens)</span>
<span class="line-number">961</span><span class="uncovered">                return (typedef_name, original_type)</span>
<span class="line-number">962</span>
<span class="line-number">963</span>        # Pointer typedef: typedef type * name;
<span class="line-number">964</span>        for i in range(len(all_tokens) - 2):
<span class="line-number">965</span>            if (
<span class="line-number">966</span>                all_tokens[i].type == TokenType.ASTERISK
</pre>
<h4>Lines 969-971</h4>
<pre>
<span class="line-number">964</span>        for i in range(len(all_tokens) - 2):
<span class="line-number">965</span>            if (
<span class="line-number">966</span>                all_tokens[i].type == TokenType.ASTERISK
<span class="line-number">967</span>                and all_tokens[i + 1].type == TokenType.IDENTIFIER
<span class="line-number">968</span>            ):
<span class="line-number">969</span><span class="uncovered">                typedef_name = all_tokens[i + 1].value</span>
<span class="line-number">970</span><span class="uncovered">                original_type = &quot; &quot;.join(t.value for t in all_tokens)</span>
<span class="line-number">971</span><span class="uncovered">                return (typedef_name, original_type)</span>
<span class="line-number">972</span>
<span class="line-number">973</span>        # Simple typedef: the last token should be the typedef name, everything else is the type
<span class="line-number">974</span>        typedef_name = all_tokens[-1].value
<span class="line-number">975</span>        type_tokens = all_tokens[:-1]
<span class="line-number">976</span>        original_type = &quot; &quot;.join(t.value for t in type_tokens)
</pre>
<h4>Line 1007</h4>
<pre>
<span class="line-number">1002</span>            elif tokens[pos].type == TokenType.RBRACE:
<span class="line-number">1003</span>                brace_count -= 1
<span class="line-number">1004</span>            pos += 1
<span class="line-number">1005</span>
<span class="line-number">1006</span>        if brace_count &gt; 0:
<span class="line-number">1007</span><span class="uncovered">            return None</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Find typedef name after closing brace
<span class="line-number">1010</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1011</span>            TokenType.WHITESPACE,
<span class="line-number">1012</span>            TokenType.COMMENT,
</pre>
<h4>Line 1036</h4>
<pre>
<span class="line-number">1031</span>            TokenType.COMMENT,
<span class="line-number">1032</span>        ]:
<span class="line-number">1033</span>            pos += 1
<span class="line-number">1034</span>
<span class="line-number">1035</span>        if pos &gt;= len(tokens):
<span class="line-number">1036</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1037</span>
<span class="line-number">1038</span>        # Check if it&#x27;s a struct/enum/union
<span class="line-number">1039</span>        if tokens[pos].type not in [TokenType.STRUCT, TokenType.ENUM, TokenType.UNION]:
<span class="line-number">1040</span>            return &quot;&quot;
<span class="line-number">1041</span>
</pre>
<h4>Line 1040</h4>
<pre>
<span class="line-number">1035</span>        if pos &gt;= len(tokens):
<span class="line-number">1036</span>            return &quot;&quot;
<span class="line-number">1037</span>
<span class="line-number">1038</span>        # Check if it&#x27;s a struct/enum/union
<span class="line-number">1039</span>        if tokens[pos].type not in [TokenType.STRUCT, TokenType.ENUM, TokenType.UNION]:
<span class="line-number">1040</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1041</span>
<span class="line-number">1042</span>        # Skip struct/enum/union keyword
<span class="line-number">1043</span>        pos += 1
<span class="line-number">1044</span>
<span class="line-number">1045</span>        # Skip whitespace and comments
</pre>
<h4>Line 1120</h4>
<pre>
<span class="line-number">1115</span>                    return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1116</span>            elif tokens[i].type == TokenType.SEMICOLON and brace_count == 0:
<span class="line-number">1117</span>                return i + 1
<span class="line-number">1118</span>            i += 1
<span class="line-number">1119</span>
<span class="line-number">1120</span><span class="uncovered">        return i</span>
<span class="line-number">1121</span>
<span class="line-number">1122</span>    def _parse_global_variable(self, tokens, start_pos):
<span class="line-number">1123</span>        &quot;&quot;&quot;Parse a global variable declaration starting at start_pos&quot;&quot;&quot;
<span class="line-number">1124</span>        # Look for pattern: [static/extern] type name [= value];
<span class="line-number">1125</span>        i = start_pos
</pre>
<h4>Line 1182</h4>
<pre>
<span class="line-number">1177</span>                                if collected_tokens[k].type == TokenType.IDENTIFIER:
<span class="line-number">1178</span>                                    var_name = collected_tokens[k].value
<span class="line-number">1179</span>                                    type_tokens = collected_tokens[start_idx:k]
<span class="line-number">1180</span>                                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1181</span>                                    return (var_name, var_type, None)
<span class="line-number">1182</span><span class="uncovered">                            break</span>
<span class="line-number">1183</span>                else:
<span class="line-number">1184</span>                    # Regular variable: last token is the name
<span class="line-number">1185</span>                    var_name = collected_tokens[-1].value
<span class="line-number">1186</span>                    type_tokens = collected_tokens[start_idx:-1]
<span class="line-number">1187</span>                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
</pre>
<h4>Lines 1202-1203</h4>
<pre>
<span class="line-number">1197</span>        return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1198</span>
<span class="line-number">1199</span>    def _skip_preprocessor_directives(self, tokens, start_pos):
<span class="line-number">1200</span>        &quot;&quot;&quot;Skip preprocessor directives but keep their content for parsing&quot;&quot;&quot;
<span class="line-number">1201</span>        # This method is deprecated - use the PreprocessorManager instead
<span class="line-number">1202</span><span class="uncovered">        i = start_pos</span>
<span class="line-number">1203</span><span class="uncovered">        while i &lt; len(tokens) and tokens[i].type == TokenType.PREPROCESSOR:</span>
<span class="line-number">1204</span>            # Skip the preprocessor directive itself
<span class="line-number">1205</span>            i += 1
<span class="line-number">1206</span>        return i
<span class="line-number">1207</span>
<span class="line-number">1208</span>    def _parse_function_parameters(self, tokens, start_pos, end_pos, func_name):
</pre>
<h4>Lines 1205-1206</h4>
<pre>
<span class="line-number">1200</span>        &quot;&quot;&quot;Skip preprocessor directives but keep their content for parsing&quot;&quot;&quot;
<span class="line-number">1201</span>        # This method is deprecated - use the PreprocessorManager instead
<span class="line-number">1202</span>        i = start_pos
<span class="line-number">1203</span>        while i &lt; len(tokens) and tokens[i].type == TokenType.PREPROCESSOR:
<span class="line-number">1204</span>            # Skip the preprocessor directive itself
<span class="line-number">1205</span><span class="uncovered">            i += 1</span>
<span class="line-number">1206</span><span class="uncovered">        return i</span>
<span class="line-number">1207</span>
<span class="line-number">1208</span>    def _parse_function_parameters(self, tokens, start_pos, end_pos, func_name):
<span class="line-number">1209</span>        &quot;&quot;&quot;Parse function parameters from token range&quot;&quot;&quot;
<span class="line-number">1210</span>
<span class="line-number">1211</span>        parameters = []
</pre>
<h4>Line 1224</h4>
<pre>
<span class="line-number">1219</span>                # Look for opening parenthesis after function name
<span class="line-number">1220</span>                for j in range(i + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1221</span>                    if tokens[j].type == TokenType.LPAREN:
<span class="line-number">1222</span>                        paren_start = j
<span class="line-number">1223</span>                        break
<span class="line-number">1224</span><span class="uncovered">                    elif tokens[j].type not in [</span>
<span class="line-number">1225</span>                        TokenType.WHITESPACE,
<span class="line-number">1226</span>                        TokenType.COMMENT,
<span class="line-number">1227</span>                    ]:
<span class="line-number">1228</span>                        break
<span class="line-number">1229</span>                break
</pre>
<h4>Line 1228</h4>
<pre>
<span class="line-number">1223</span>                        break
<span class="line-number">1224</span>                    elif tokens[j].type not in [
<span class="line-number">1225</span>                        TokenType.WHITESPACE,
<span class="line-number">1226</span>                        TokenType.COMMENT,
<span class="line-number">1227</span>                    ]:
<span class="line-number">1228</span><span class="uncovered">                        break</span>
<span class="line-number">1229</span>                break
<span class="line-number">1230</span>
<span class="line-number">1231</span>        if paren_start is None:
<span class="line-number">1232</span>            return parameters
<span class="line-number">1233</span>
</pre>
<h4>Line 1232</h4>
<pre>
<span class="line-number">1227</span>                    ]:
<span class="line-number">1228</span>                        break
<span class="line-number">1229</span>                break
<span class="line-number">1230</span>
<span class="line-number">1231</span>        if paren_start is None:
<span class="line-number">1232</span><span class="uncovered">            return parameters</span>
<span class="line-number">1233</span>
<span class="line-number">1234</span>        # Find matching closing parenthesis
<span class="line-number">1235</span>        paren_depth = 1
<span class="line-number">1236</span>        for i in range(paren_start + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1237</span>            if tokens[i].type == TokenType.LPAREN:
</pre>
<h4>Line 1246</h4>
<pre>
<span class="line-number">1241</span>                if paren_depth == 0:
<span class="line-number">1242</span>                    paren_end = i
<span class="line-number">1243</span>                    break
<span class="line-number">1244</span>
<span class="line-number">1245</span>        if paren_end is None:
<span class="line-number">1246</span><span class="uncovered">            return parameters</span>
<span class="line-number">1247</span>
<span class="line-number">1248</span>        # Parse parameter tokens between parentheses
<span class="line-number">1249</span>        param_tokens = []
<span class="line-number">1250</span>        for i in range(paren_start + 1, paren_end):
<span class="line-number">1251</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
</pre>
<h4>Line 1285</h4>
<pre>
<span class="line-number">1280</span>    def _parse_single_parameter(self, param_tokens):
<span class="line-number">1281</span>        &quot;&quot;&quot;Parse a single function parameter from tokens&quot;&quot;&quot;
<span class="line-number">1282</span>        from .models import Field
<span class="line-number">1283</span>
<span class="line-number">1284</span>        if not param_tokens:
<span class="line-number">1285</span><span class="uncovered">            return None</span>
<span class="line-number">1286</span>
<span class="line-number">1287</span>        # Handle variadic parameters (three consecutive dots)
<span class="line-number">1288</span>        if len(param_tokens) == 3 and all(t.value == &quot;.&quot; for t in param_tokens):
<span class="line-number">1289</span>            return Field(name=&quot;...&quot;, type=&quot;...&quot;)
<span class="line-number">1290</span>
</pre>
<h4>Line 1293</h4>
<pre>
<span class="line-number">1288</span>        if len(param_tokens) == 3 and all(t.value == &quot;.&quot; for t in param_tokens):
<span class="line-number">1289</span>            return Field(name=&quot;...&quot;, type=&quot;...&quot;)
<span class="line-number">1290</span>
<span class="line-number">1291</span>        # Handle variadic parameters (single ... token)
<span class="line-number">1292</span>        if len(param_tokens) == 1 and param_tokens[0].value == &quot;...&quot;:
<span class="line-number">1293</span><span class="uncovered">            return Field(name=&quot;...&quot;, type=&quot;...&quot;)</span>
<span class="line-number">1294</span>
<span class="line-number">1295</span>        # For parameters like &quot;int x&quot; or &quot;const char *name&quot;
<span class="line-number">1296</span>        if len(param_tokens) &gt;= 2:
<span class="line-number">1297</span>            # Last token is usually the parameter name
<span class="line-number">1298</span>            param_name = param_tokens[-1].value
</pre>
<h4>Lines 1340-1341</h4>
<pre>
<span class="line-number">1335</span>                &quot;signed&quot;,
<span class="line-number">1336</span>            ]:
<span class="line-number">1337</span>                return Field(name=&quot;unnamed&quot;, type=token_value)
<span class="line-number">1338</span>            else:
<span class="line-number">1339</span>                # If we can&#x27;t determine the type, use &#x27;unknown&#x27; as a fallback
<span class="line-number">1340</span><span class="uncovered">                if token_value and token_value.strip():</span>
<span class="line-number">1341</span><span class="uncovered">                    return Field(name=token_value.strip(), type=&quot;unknown&quot;)</span>
<span class="line-number">1342</span>                else:
<span class="line-number">1343</span>                    return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)
<span class="line-number">1344</span>
<span class="line-number">1345</span>        return None
<span class="line-number">1346</span>
</pre>
<h4>Line 1343</h4>
<pre>
<span class="line-number">1338</span>            else:
<span class="line-number">1339</span>                # If we can&#x27;t determine the type, use &#x27;unknown&#x27; as a fallback
<span class="line-number">1340</span>                if token_value and token_value.strip():
<span class="line-number">1341</span>                    return Field(name=token_value.strip(), type=&quot;unknown&quot;)
<span class="line-number">1342</span>                else:
<span class="line-number">1343</span><span class="uncovered">                    return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)</span>
<span class="line-number">1344</span>
<span class="line-number">1345</span>        return None
<span class="line-number">1346</span>
<span class="line-number">1347</span>    def _get_timestamp(self) -&gt; str:
<span class="line-number">1348</span>        &quot;&quot;&quot;Get current timestamp string&quot;&quot;&quot;
</pre>
<h4>Line 1345</h4>
<pre>
<span class="line-number">1340</span>                if token_value and token_value.strip():
<span class="line-number">1341</span>                    return Field(name=token_value.strip(), type=&quot;unknown&quot;)
<span class="line-number">1342</span>                else:
<span class="line-number">1343</span>                    return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)
<span class="line-number">1344</span>
<span class="line-number">1345</span><span class="uncovered">        return None</span>
<span class="line-number">1346</span>
<span class="line-number">1347</span>    def _get_timestamp(self) -&gt; str:
<span class="line-number">1348</span>        &quot;&quot;&quot;Get current timestamp string&quot;&quot;&quot;
<span class="line-number">1349</span>        from datetime import datetime
<span class="line-number">1350</span>
</pre>
<h4>Line 1349</h4>
<pre>
<span class="line-number">1344</span>
<span class="line-number">1345</span>        return None
<span class="line-number">1346</span>
<span class="line-number">1347</span>    def _get_timestamp(self) -&gt; str:
<span class="line-number">1348</span>        &quot;&quot;&quot;Get current timestamp string&quot;&quot;&quot;
<span class="line-number">1349</span><span class="uncovered">        from datetime import datetime</span>
<span class="line-number">1350</span>
<span class="line-number">1351</span>        return datetime.now().isoformat()
<span class="line-number">1352</span>
<span class="line-number">1353</span>    def get_failed_includes_cache_stats(self) -&gt; dict:
<span class="line-number">1354</span>        &quot;&quot;&quot;Get statistics about the failed includes cache&quot;&quot;&quot;
</pre>
<h4>Line 1351</h4>
<pre>
<span class="line-number">1346</span>
<span class="line-number">1347</span>    def _get_timestamp(self) -&gt; str:
<span class="line-number">1348</span>        &quot;&quot;&quot;Get current timestamp string&quot;&quot;&quot;
<span class="line-number">1349</span>        from datetime import datetime
<span class="line-number">1350</span>
<span class="line-number">1351</span><span class="uncovered">        return datetime.now().isoformat()</span>
<span class="line-number">1352</span>
<span class="line-number">1353</span>    def get_failed_includes_cache_stats(self) -&gt; dict:
<span class="line-number">1354</span>        &quot;&quot;&quot;Get statistics about the failed includes cache&quot;&quot;&quot;
<span class="line-number">1355</span>        return {
<span class="line-number">1356</span>            &quot;cache_size&quot;: len(self._failed_includes_cache),
</pre>
<h4>Line 1355</h4>
<pre>
<span class="line-number">1350</span>
<span class="line-number">1351</span>        return datetime.now().isoformat()
<span class="line-number">1352</span>
<span class="line-number">1353</span>    def get_failed_includes_cache_stats(self) -&gt; dict:
<span class="line-number">1354</span>        &quot;&quot;&quot;Get statistics about the failed includes cache&quot;&quot;&quot;
<span class="line-number">1355</span><span class="uncovered">        return {</span>
<span class="line-number">1356</span>            &quot;cache_size&quot;: len(self._failed_includes_cache),
<span class="line-number">1357</span>            &quot;cached_includes&quot;: list(self._failed_includes_cache),
<span class="line-number">1358</span>        }
<span class="line-number">1359</span>
<span class="line-number">1360</span>
</pre>
</div>
<div class="file-section">
<div class="file-header">
/workspace/c_to_plantuml/models.py - 86.54% coverage (225/260 lines)
</div>
<h4>Line 27</h4>
<pre>
<span class="line-number"> 22</span>        return f&quot;Field(name={self.name}, type={self.type})&quot;
<span class="line-number"> 23</span>
<span class="line-number"> 24</span>    def __post_init__(self):
<span class="line-number"> 25</span>        &quot;&quot;&quot;Validate field data after initialization&quot;&quot;&quot;
<span class="line-number"> 26</span>        if not isinstance(self.name, str):
<span class="line-number"> 27</span><span class="uncovered">            raise ValueError(</span>
<span class="line-number"> 28</span>                f&quot;Field name must be a string, got {type(self.name)}: {repr(self.name)}&quot;
<span class="line-number"> 29</span>            )
<span class="line-number"> 30</span>        if not self.type or not isinstance(self.type, str):
<span class="line-number"> 31</span>            raise ValueError(
<span class="line-number"> 32</span>                f&quot;Field type must be a non-empty string, got {type(self.type)}: {repr(self.type)}&quot;
</pre>
<h4>Line 31</h4>
<pre>
<span class="line-number"> 26</span>        if not isinstance(self.name, str):
<span class="line-number"> 27</span>            raise ValueError(
<span class="line-number"> 28</span>                f&quot;Field name must be a string, got {type(self.name)}: {repr(self.name)}&quot;
<span class="line-number"> 29</span>            )
<span class="line-number"> 30</span>        if not self.type or not isinstance(self.type, str):
<span class="line-number"> 31</span><span class="uncovered">            raise ValueError(</span>
<span class="line-number"> 32</span>                f&quot;Field type must be a non-empty string, got {type(self.type)}: {repr(self.type)}&quot;
<span class="line-number"> 33</span>            )
<span class="line-number"> 34</span>
<span class="line-number"> 35</span>        # Additional validation: ensure name and type are not just whitespace
<span class="line-number"> 36</span>        if not self.name.strip():
</pre>
<h4>Line 37</h4>
<pre>
<span class="line-number"> 32</span>                f&quot;Field type must be a non-empty string, got {type(self.type)}: {repr(self.type)}&quot;
<span class="line-number"> 33</span>            )
<span class="line-number"> 34</span>
<span class="line-number"> 35</span>        # Additional validation: ensure name and type are not just whitespace
<span class="line-number"> 36</span>        if not self.name.strip():
<span class="line-number"> 37</span><span class="uncovered">            raise ValueError(</span>
<span class="line-number"> 38</span>                f&quot;Field name cannot be empty or whitespace, got: {repr(self.name)}&quot;
<span class="line-number"> 39</span>            )
<span class="line-number"> 40</span>        if not self.type.strip():
<span class="line-number"> 41</span>            raise ValueError(
<span class="line-number"> 42</span>                f&quot;Field type cannot be empty or whitespace, got: {repr(self.type)}&quot;
</pre>
<h4>Line 41</h4>
<pre>
<span class="line-number"> 36</span>        if not self.name.strip():
<span class="line-number"> 37</span>            raise ValueError(
<span class="line-number"> 38</span>                f&quot;Field name cannot be empty or whitespace, got: {repr(self.name)}&quot;
<span class="line-number"> 39</span>            )
<span class="line-number"> 40</span>        if not self.type.strip():
<span class="line-number"> 41</span><span class="uncovered">            raise ValueError(</span>
<span class="line-number"> 42</span>                f&quot;Field type cannot be empty or whitespace, got: {repr(self.type)}&quot;
<span class="line-number"> 43</span>            )
<span class="line-number"> 44</span>
<span class="line-number"> 45</span>
<span class="line-number"> 46</span># TypedefRelation class removed - tag names moved to struct/enum/union
</pre>
<h4>Line 60</h4>
<pre>
<span class="line-number"> 55</span>    depth: int
<span class="line-number"> 56</span>
<span class="line-number"> 57</span>    def __post_init__(self):
<span class="line-number"> 58</span>        &quot;&quot;&quot;Validate include relation data after initialization&quot;&quot;&quot;
<span class="line-number"> 59</span>        if not self.source_file or not isinstance(self.source_file, str):
<span class="line-number"> 60</span><span class="uncovered">            raise ValueError(&quot;Source file must be a non-empty string&quot;)</span>
<span class="line-number"> 61</span>        if not self.included_file or not isinstance(self.included_file, str):
<span class="line-number"> 62</span>            raise ValueError(&quot;Included file must be a non-empty string&quot;)
<span class="line-number"> 63</span>        if not isinstance(self.depth, int) or self.depth &lt; 0:
<span class="line-number"> 64</span>            raise ValueError(&quot;Depth must be a non-negative integer&quot;)
<span class="line-number"> 65</span>
</pre>
<h4>Line 62</h4>
<pre>
<span class="line-number"> 57</span>    def __post_init__(self):
<span class="line-number"> 58</span>        &quot;&quot;&quot;Validate include relation data after initialization&quot;&quot;&quot;
<span class="line-number"> 59</span>        if not self.source_file or not isinstance(self.source_file, str):
<span class="line-number"> 60</span>            raise ValueError(&quot;Source file must be a non-empty string&quot;)
<span class="line-number"> 61</span>        if not self.included_file or not isinstance(self.included_file, str):
<span class="line-number"> 62</span><span class="uncovered">            raise ValueError(&quot;Included file must be a non-empty string&quot;)</span>
<span class="line-number"> 63</span>        if not isinstance(self.depth, int) or self.depth &lt; 0:
<span class="line-number"> 64</span>            raise ValueError(&quot;Depth must be a non-negative integer&quot;)
<span class="line-number"> 65</span>
<span class="line-number"> 66</span>
<span class="line-number"> 67</span>@dataclass
</pre>
<h4>Line 64</h4>
<pre>
<span class="line-number"> 59</span>        if not self.source_file or not isinstance(self.source_file, str):
<span class="line-number"> 60</span>            raise ValueError(&quot;Source file must be a non-empty string&quot;)
<span class="line-number"> 61</span>        if not self.included_file or not isinstance(self.included_file, str):
<span class="line-number"> 62</span>            raise ValueError(&quot;Included file must be a non-empty string&quot;)
<span class="line-number"> 63</span>        if not isinstance(self.depth, int) or self.depth &lt; 0:
<span class="line-number"> 64</span><span class="uncovered">            raise ValueError(&quot;Depth must be a non-negative integer&quot;)</span>
<span class="line-number"> 65</span>
<span class="line-number"> 66</span>
<span class="line-number"> 67</span>@dataclass
<span class="line-number"> 68</span>class Function:
<span class="line-number"> 69</span>    &quot;&quot;&quot;Represents a function&quot;&quot;&quot;
</pre>
<h4>Line 80</h4>
<pre>
<span class="line-number"> 75</span>    is_declaration: bool = False
<span class="line-number"> 76</span>
<span class="line-number"> 77</span>    def __post_init__(self):
<span class="line-number"> 78</span>        &quot;&quot;&quot;Validate function data after initialization&quot;&quot;&quot;
<span class="line-number"> 79</span>        if not self.name or not isinstance(self.name, str):
<span class="line-number"> 80</span><span class="uncovered">            raise ValueError(&quot;Function name must be a non-empty string&quot;)</span>
<span class="line-number"> 81</span>        if not self.return_type or not isinstance(self.return_type, str):
<span class="line-number"> 82</span>            raise ValueError(&quot;Function return type must be a non-empty string&quot;)
<span class="line-number"> 83</span>
<span class="line-number"> 84</span>        # Convert parameters to Field objects if they&#x27;re dictionaries
<span class="line-number"> 85</span>        if self.parameters:
</pre>
<h4>Line 82</h4>
<pre>
<span class="line-number"> 77</span>    def __post_init__(self):
<span class="line-number"> 78</span>        &quot;&quot;&quot;Validate function data after initialization&quot;&quot;&quot;
<span class="line-number"> 79</span>        if not self.name or not isinstance(self.name, str):
<span class="line-number"> 80</span>            raise ValueError(&quot;Function name must be a non-empty string&quot;)
<span class="line-number"> 81</span>        if not self.return_type or not isinstance(self.return_type, str):
<span class="line-number"> 82</span><span class="uncovered">            raise ValueError(&quot;Function return type must be a non-empty string&quot;)</span>
<span class="line-number"> 83</span>
<span class="line-number"> 84</span>        # Convert parameters to Field objects if they&#x27;re dictionaries
<span class="line-number"> 85</span>        if self.parameters:
<span class="line-number"> 86</span>            converted_params = []
<span class="line-number"> 87</span>            for param in self.parameters:
</pre>
<h4>Line 110</h4>
<pre>
<span class="line-number">105</span>    )  # Non-primitive types used by this struct
<span class="line-number">106</span>
<span class="line-number">107</span>    def __post_init__(self):
<span class="line-number">108</span>        &quot;&quot;&quot;Validate struct data after initialization&quot;&quot;&quot;
<span class="line-number">109</span>        if not self.name or not isinstance(self.name, str):
<span class="line-number">110</span><span class="uncovered">            raise ValueError(&quot;Struct name must be a non-empty string&quot;)</span>
<span class="line-number">111</span>
<span class="line-number">112</span>
<span class="line-number">113</span>@dataclass
<span class="line-number">114</span>class EnumValue:
<span class="line-number">115</span>    name: str
</pre>
<h4>Line 120</h4>
<pre>
<span class="line-number">115</span>    name: str
<span class="line-number">116</span>    value: Optional[str] = None
<span class="line-number">117</span>
<span class="line-number">118</span>    def __post_init__(self):
<span class="line-number">119</span>        if not self.name or not isinstance(self.name, str):
<span class="line-number">120</span><span class="uncovered">            raise ValueError(&quot;Enum value name must be a non-empty string&quot;)</span>
<span class="line-number">121</span>
<span class="line-number">122</span>
<span class="line-number">123</span>@dataclass
<span class="line-number">124</span>class Enum:
<span class="line-number">125</span>    &quot;&quot;&quot;Represents a C enum&quot;&quot;&quot;
</pre>
<h4>Line 133</h4>
<pre>
<span class="line-number">128</span>    values: List[EnumValue] = field(default_factory=list)
<span class="line-number">129</span>    tag_name: str = &quot;&quot;  # Tag name for typedef enums
<span class="line-number">130</span>
<span class="line-number">131</span>    def __post_init__(self):
<span class="line-number">132</span>        if not self.name or not isinstance(self.name, str):
<span class="line-number">133</span><span class="uncovered">            raise ValueError(&quot;Enum name must be a non-empty string&quot;)</span>
<span class="line-number">134</span>        # Convert any string values to EnumValue
<span class="line-number">135</span>        self.values = [
<span class="line-number">136</span>            v if isinstance(v, EnumValue) else EnumValue(v) for v in self.values
<span class="line-number">137</span>        ]
<span class="line-number">138</span>
</pre>
<h4>Line 154</h4>
<pre>
<span class="line-number">149</span>    )  # Non-primitive types used by this union
<span class="line-number">150</span>
<span class="line-number">151</span>    def __post_init__(self):
<span class="line-number">152</span>        &quot;&quot;&quot;Validate union data after initialization&quot;&quot;&quot;
<span class="line-number">153</span>        if not self.name or not isinstance(self.name, str):
<span class="line-number">154</span><span class="uncovered">            raise ValueError(&quot;Union name must be a non-empty string&quot;)</span>
<span class="line-number">155</span>
<span class="line-number">156</span>
<span class="line-number">157</span>@dataclass
<span class="line-number">158</span>class Alias:
<span class="line-number">159</span>    &quot;&quot;&quot;Represents a type alias (typedef)&quot;&quot;&quot;
</pre>
<h4>Line 170</h4>
<pre>
<span class="line-number">165</span>    )  # Non-primitive types used by this alias
<span class="line-number">166</span>
<span class="line-number">167</span>    def __post_init__(self):
<span class="line-number">168</span>        &quot;&quot;&quot;Validate alias data after initialization&quot;&quot;&quot;
<span class="line-number">169</span>        if not self.name or not isinstance(self.name, str):
<span class="line-number">170</span><span class="uncovered">            raise ValueError(&quot;Alias name must be a non-empty string&quot;)</span>
<span class="line-number">171</span>        if not self.original_type or not isinstance(self.original_type, str):
<span class="line-number">172</span>            raise ValueError(&quot;Original type must be a non-empty string&quot;)
<span class="line-number">173</span>
<span class="line-number">174</span>
<span class="line-number">175</span>@dataclass
</pre>
<h4>Line 172</h4>
<pre>
<span class="line-number">167</span>    def __post_init__(self):
<span class="line-number">168</span>        &quot;&quot;&quot;Validate alias data after initialization&quot;&quot;&quot;
<span class="line-number">169</span>        if not self.name or not isinstance(self.name, str):
<span class="line-number">170</span>            raise ValueError(&quot;Alias name must be a non-empty string&quot;)
<span class="line-number">171</span>        if not self.original_type or not isinstance(self.original_type, str):
<span class="line-number">172</span><span class="uncovered">            raise ValueError(&quot;Original type must be a non-empty string&quot;)</span>
<span class="line-number">173</span>
<span class="line-number">174</span>
<span class="line-number">175</span>@dataclass
<span class="line-number">176</span>class FileModel:
<span class="line-number">177</span>    &quot;&quot;&quot;Represents a parsed C/C++ file&quot;&quot;&quot;
</pre>
<h4>Line 196</h4>
<pre>
<span class="line-number">191</span>    include_relations: List[IncludeRelation] = field(default_factory=list)
<span class="line-number">192</span>
<span class="line-number">193</span>    def __post_init__(self):
<span class="line-number">194</span>        &quot;&quot;&quot;Validate file model data after initialization&quot;&quot;&quot;
<span class="line-number">195</span>        if not self.file_path or not isinstance(self.file_path, str):
<span class="line-number">196</span><span class="uncovered">            raise ValueError(&quot;File path must be a non-empty string&quot;)</span>
<span class="line-number">197</span>        if not self.relative_path or not isinstance(self.relative_path, str):
<span class="line-number">198</span>            raise ValueError(&quot;Relative path must be a non-empty string&quot;)
<span class="line-number">199</span>        if not self.project_root or not isinstance(self.project_root, str):
<span class="line-number">200</span>            raise ValueError(&quot;Project root must be a non-empty string&quot;)
<span class="line-number">201</span>        if not self.encoding_used or not isinstance(self.encoding_used, str):
</pre>
<h4>Line 198</h4>
<pre>
<span class="line-number">193</span>    def __post_init__(self):
<span class="line-number">194</span>        &quot;&quot;&quot;Validate file model data after initialization&quot;&quot;&quot;
<span class="line-number">195</span>        if not self.file_path or not isinstance(self.file_path, str):
<span class="line-number">196</span>            raise ValueError(&quot;File path must be a non-empty string&quot;)
<span class="line-number">197</span>        if not self.relative_path or not isinstance(self.relative_path, str):
<span class="line-number">198</span><span class="uncovered">            raise ValueError(&quot;Relative path must be a non-empty string&quot;)</span>
<span class="line-number">199</span>        if not self.project_root or not isinstance(self.project_root, str):
<span class="line-number">200</span>            raise ValueError(&quot;Project root must be a non-empty string&quot;)
<span class="line-number">201</span>        if not self.encoding_used or not isinstance(self.encoding_used, str):
<span class="line-number">202</span>            raise ValueError(&quot;Encoding must be a non-empty string&quot;)
<span class="line-number">203</span>
</pre>
<h4>Line 200</h4>
<pre>
<span class="line-number">195</span>        if not self.file_path or not isinstance(self.file_path, str):
<span class="line-number">196</span>            raise ValueError(&quot;File path must be a non-empty string&quot;)
<span class="line-number">197</span>        if not self.relative_path or not isinstance(self.relative_path, str):
<span class="line-number">198</span>            raise ValueError(&quot;Relative path must be a non-empty string&quot;)
<span class="line-number">199</span>        if not self.project_root or not isinstance(self.project_root, str):
<span class="line-number">200</span><span class="uncovered">            raise ValueError(&quot;Project root must be a non-empty string&quot;)</span>
<span class="line-number">201</span>        if not self.encoding_used or not isinstance(self.encoding_used, str):
<span class="line-number">202</span>            raise ValueError(&quot;Encoding must be a non-empty string&quot;)
<span class="line-number">203</span>
<span class="line-number">204</span>    def to_dict(self) -&gt; dict:
<span class="line-number">205</span>        &quot;&quot;&quot;Convert to dictionary for JSON serialization&quot;&quot;&quot;
</pre>
<h4>Line 202</h4>
<pre>
<span class="line-number">197</span>        if not self.relative_path or not isinstance(self.relative_path, str):
<span class="line-number">198</span>            raise ValueError(&quot;Relative path must be a non-empty string&quot;)
<span class="line-number">199</span>        if not self.project_root or not isinstance(self.project_root, str):
<span class="line-number">200</span>            raise ValueError(&quot;Project root must be a non-empty string&quot;)
<span class="line-number">201</span>        if not self.encoding_used or not isinstance(self.encoding_used, str):
<span class="line-number">202</span><span class="uncovered">            raise ValueError(&quot;Encoding must be a non-empty string&quot;)</span>
<span class="line-number">203</span>
<span class="line-number">204</span>    def to_dict(self) -&gt; dict:
<span class="line-number">205</span>        &quot;&quot;&quot;Convert to dictionary for JSON serialization&quot;&quot;&quot;
<span class="line-number">206</span>        data = asdict(self)
<span class="line-number">207</span>        # Convert set to list for JSON serialization and sort for consistency
</pre>
<h4>Line 278</h4>
<pre>
<span class="line-number">273</span>                    methods=methods,
<span class="line-number">274</span>                    tag_name=struct_data.get(&quot;tag_name&quot;, &quot;&quot;),
<span class="line-number">275</span>                    uses=struct_data.get(&quot;uses&quot;, []),
<span class="line-number">276</span>                )
<span class="line-number">277</span>            else:
<span class="line-number">278</span><span class="uncovered">                structs[name] = struct_data</span>
<span class="line-number">279</span>
<span class="line-number">280</span>        # Convert enums back to Enum objects
<span class="line-number">281</span>        enums_data = data.get(&quot;enums&quot;, {})
<span class="line-number">282</span>        enums = {}
<span class="line-number">283</span>        for name, enum_data in enums_data.items():
</pre>
<h4>Line 291</h4>
<pre>
<span class="line-number">286</span>                    EnumValue(**val) if isinstance(val, dict) else EnumValue(val)
<span class="line-number">287</span>                    for val in enum_data.get(&quot;values&quot;, [])
<span class="line-number">288</span>                ]
<span class="line-number">289</span>                enums[name] = Enum(name=enum_data.get(&quot;name&quot;, name), values=values)
<span class="line-number">290</span>            else:
<span class="line-number">291</span><span class="uncovered">                enums[name] = enum_data</span>
<span class="line-number">292</span>
<span class="line-number">293</span>        # typedef_relations removed - tag names are now in struct/enum/union
<span class="line-number">294</span>
<span class="line-number">295</span>        # Convert include_relations back to IncludeRelation objects
<span class="line-number">296</span>        include_relations_data = data.get(&quot;include_relations&quot;, [])
</pre>
<h4>Line 318</h4>
<pre>
<span class="line-number">313</span>                    fields=fields,
<span class="line-number">314</span>                    tag_name=union_data.get(&quot;tag_name&quot;, &quot;&quot;),
<span class="line-number">315</span>                    uses=union_data.get(&quot;uses&quot;, []),
<span class="line-number">316</span>                )
<span class="line-number">317</span>            else:
<span class="line-number">318</span><span class="uncovered">                unions[name] = union_data</span>
<span class="line-number">319</span>
<span class="line-number">320</span>        # Convert aliases back to Alias objects
<span class="line-number">321</span>        aliases_data = data.get(&quot;aliases&quot;, {})
<span class="line-number">322</span>        aliases = {}
<span class="line-number">323</span>        for name, alias_data in aliases_data.items():
</pre>
<h4>Line 332</h4>
<pre>
<span class="line-number">327</span>                    original_type=alias_data.get(&quot;original_type&quot;, &quot;&quot;),
<span class="line-number">328</span>                    uses=alias_data.get(&quot;uses&quot;, []),
<span class="line-number">329</span>                )
<span class="line-number">330</span>            else:
<span class="line-number">331</span>                # Handle legacy format where aliases was Dict[str, str]
<span class="line-number">332</span><span class="uncovered">                aliases[name] = Alias(name=name, original_type=alias_data, uses=[])</span>
<span class="line-number">333</span>
<span class="line-number">334</span>        # Create new data dict with converted objects
<span class="line-number">335</span>        new_data = data.copy()
<span class="line-number">336</span>        new_data[&quot;includes&quot;] = includes
<span class="line-number">337</span>        new_data[&quot;globals&quot;] = globals
</pre>
<h4>Line 349</h4>
<pre>
<span class="line-number">344</span>
<span class="line-number">345</span>        return cls(**new_data)
<span class="line-number">346</span>
<span class="line-number">347</span>    def get_summary(self) -&gt; dict:
<span class="line-number">348</span>        &quot;&quot;&quot;Get a summary of the file contents&quot;&quot;&quot;
<span class="line-number">349</span><span class="uncovered">        return {</span>
<span class="line-number">350</span>            &quot;file_path&quot;: self.file_path,
<span class="line-number">351</span>            &quot;structs_count&quot;: len(self.structs),
<span class="line-number">352</span>            &quot;enums_count&quot;: len(self.enums),
<span class="line-number">353</span>            &quot;functions_count&quot;: len(self.functions),
<span class="line-number">354</span>            &quot;globals_count&quot;: len(self.globals),
</pre>
<h4>Line 372</h4>
<pre>
<span class="line-number">367</span>    files: Dict[str, FileModel] = field(default_factory=dict)
<span class="line-number">368</span>
<span class="line-number">369</span>    def __post_init__(self):
<span class="line-number">370</span>        &quot;&quot;&quot;Validate project model data after initialization&quot;&quot;&quot;
<span class="line-number">371</span>        if not self.project_name or not isinstance(self.project_name, str):
<span class="line-number">372</span><span class="uncovered">            raise ValueError(&quot;Project name must be a non-empty string&quot;)</span>
<span class="line-number">373</span>        if not self.project_root or not isinstance(self.project_root, str):
<span class="line-number">374</span>            raise ValueError(&quot;Project root must be a non-empty string&quot;)
<span class="line-number">375</span>
<span class="line-number">376</span>    def save(self, file_path: str) -&gt; None:
<span class="line-number">377</span>        &quot;&quot;&quot;Save model to JSON file&quot;&quot;&quot;
</pre>
<h4>Line 374</h4>
<pre>
<span class="line-number">369</span>    def __post_init__(self):
<span class="line-number">370</span>        &quot;&quot;&quot;Validate project model data after initialization&quot;&quot;&quot;
<span class="line-number">371</span>        if not self.project_name or not isinstance(self.project_name, str):
<span class="line-number">372</span>            raise ValueError(&quot;Project name must be a non-empty string&quot;)
<span class="line-number">373</span>        if not self.project_root or not isinstance(self.project_root, str):
<span class="line-number">374</span><span class="uncovered">            raise ValueError(&quot;Project root must be a non-empty string&quot;)</span>
<span class="line-number">375</span>
<span class="line-number">376</span>    def save(self, file_path: str) -&gt; None:
<span class="line-number">377</span>        &quot;&quot;&quot;Save model to JSON file&quot;&quot;&quot;
<span class="line-number">378</span>        data = {
<span class="line-number">379</span>            &quot;project_name&quot;: self.project_name,
</pre>
<h4>Lines 390-391</h4>
<pre>
<span class="line-number">385</span>        }
<span class="line-number">386</span>
<span class="line-number">387</span>        try:
<span class="line-number">388</span>            with open(file_path, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:
<span class="line-number">389</span>                json.dump(data, f, indent=2, ensure_ascii=False, sort_keys=True)
<span class="line-number">390</span><span class="uncovered">        except Exception as e:</span>
<span class="line-number">391</span><span class="uncovered">            raise ValueError(f&quot;Failed to save model to {file_path}: {e}&quot;) from e</span>
<span class="line-number">392</span>
<span class="line-number">393</span>    @classmethod
<span class="line-number">394</span>    def from_dict(cls, data: dict) -&gt; &quot;ProjectModel&quot;:
<span class="line-number">395</span>        &quot;&quot;&quot;Create from dictionary&quot;&quot;&quot;
<span class="line-number">396</span>        files = {
</pre>
<h4>Lines 414-415</h4>
<pre>
<span class="line-number">409</span>        &quot;&quot;&quot;Load model from JSON file&quot;&quot;&quot;
<span class="line-number">410</span>        try:
<span class="line-number">411</span>            with open(file_path, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:
<span class="line-number">412</span>                data = json.load(f)
<span class="line-number">413</span>            return cls.from_dict(data)
<span class="line-number">414</span><span class="uncovered">        except Exception as e:</span>
<span class="line-number">415</span><span class="uncovered">            raise ValueError(f&quot;Failed to load model from {file_path}: {e}&quot;) from e</span>
<span class="line-number">416</span>
<span class="line-number">417</span>    def get_summary(self) -&gt; dict:
<span class="line-number">418</span>        &quot;&quot;&quot;Get a summary of the project&quot;&quot;&quot;
<span class="line-number">419</span>        total_structs = sum(len(f.structs) for f in self.files.values())
<span class="line-number">420</span>        total_enums = sum(len(f.enums) for f in self.files.values())
</pre>
<h4>Lines 419-422</h4>
<pre>
<span class="line-number">414</span>        except Exception as e:
<span class="line-number">415</span>            raise ValueError(f&quot;Failed to load model from {file_path}: {e}&quot;) from e
<span class="line-number">416</span>
<span class="line-number">417</span>    def get_summary(self) -&gt; dict:
<span class="line-number">418</span>        &quot;&quot;&quot;Get a summary of the project&quot;&quot;&quot;
<span class="line-number">419</span><span class="uncovered">        total_structs = sum(len(f.structs) for f in self.files.values())</span>
<span class="line-number">420</span><span class="uncovered">        total_enums = sum(len(f.enums) for f in self.files.values())</span>
<span class="line-number">421</span><span class="uncovered">        total_functions = sum(len(f.functions) for f in self.files.values())</span>
<span class="line-number">422</span><span class="uncovered">        total_globals = sum(len(f.globals) for f in self.files.values())</span>
<span class="line-number">423</span>
<span class="line-number">424</span>        return {
<span class="line-number">425</span>            &quot;project_name&quot;: self.project_name,
<span class="line-number">426</span>            &quot;project_root&quot;: self.project_root,
<span class="line-number">427</span>            &quot;files_count&quot;: len(self.files),
</pre>
<h4>Line 424</h4>
<pre>
<span class="line-number">419</span>        total_structs = sum(len(f.structs) for f in self.files.values())
<span class="line-number">420</span>        total_enums = sum(len(f.enums) for f in self.files.values())
<span class="line-number">421</span>        total_functions = sum(len(f.functions) for f in self.files.values())
<span class="line-number">422</span>        total_globals = sum(len(f.globals) for f in self.files.values())
<span class="line-number">423</span>
<span class="line-number">424</span><span class="uncovered">        return {</span>
<span class="line-number">425</span>            &quot;project_name&quot;: self.project_name,
<span class="line-number">426</span>            &quot;project_root&quot;: self.project_root,
<span class="line-number">427</span>            &quot;files_count&quot;: len(self.files),
<span class="line-number">428</span>            &quot;total_structs&quot;: total_structs,
<span class="line-number">429</span>            &quot;total_enums&quot;: total_enums,
</pre>
</div>

    <div class="footer">
        <p>Generated by Test Report System</p>
    </div>
</body>
</html>